<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李文涛的学习笔记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-16T11:29:25.461Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李文涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux网络编程（二）</title>
    <link href="http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-12-16T11:28:03.000Z</published>
    <updated>2022-12-16T11:29:25.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-x2F-O-多路复用"><a href="#I-x2F-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><p>主要目的是为了使得程序能同时监听多个文件描述符，能够提高程序的性能。（socket 通信其实就是一种对文件描述符的读取和写入）</p><p>几种常见的 I&#x2F;O 模型：</p><ol><li>阻塞等待（BIO 模型）<ol><li>好处：不占用CPU宝贵的时间片</li><li>缺点：同一时刻只能处理一个操作，效率低</li><li>解决方法：多线程或者多进程解决。但是线程、进程也会消耗较多资源</li></ol></li><li>非阻塞，忙轮询（NIO 模型）<ol><li>优点：提高了程序的执行效率</li><li>缺点：需要占用更多的资源</li><li>解决方法：I&#x2F;O 多路复用</li></ol></li></ol><p>I&#x2F;O 多路转接技术</p><ol><li>select&#x2F;poll</li><li>epoll</li></ol><h3 id="select-API-介绍"><a href="#select-API-介绍" class="headerlink" title="select API 介绍"></a>select API 介绍</h3><p>首先构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。然后调用一个系统函数，监听列表中的文件描述符，直到该列表中有文件描述符进行了 I&#x2F;O 操作时，该函数才返回。在返回时，它会告诉进程有多少描述符要进行 I&#x2F;O 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// sizeof(fd_set) = 128 1024</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line">    /*- 参数:</span><br><span class="line">        - nfds : 委托内核检测的最大文件描述符的值 + 1</span><br><span class="line">        - readfds : 要检测的文件描述符的读的集合,委托内核检测哪些文件描述符的读的属性</span><br><span class="line">            - 一般检测读操作</span><br><span class="line">            - 对应的是对方发送过来的数据,因为读是被动的接收数据,检测的就是读缓冲区</span><br><span class="line">            - 是一个传入传出参数</span><br><span class="line">        - writefds : 要检测的文件描述符的写的集合,委托内核检测哪些文件描述符的写的属性</span><br><span class="line">            - 委托内核检测写缓冲区是不是还可以写数据(不满的就可以写)</span><br><span class="line">        - exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">        - timeout : 设置的超时时间</span><br><span class="line">            struct timeval &#123;</span><br><span class="line">                long tv_sec;    seconds</span><br><span class="line">                long tv_usec;   microseconds</span><br><span class="line">            &#125;;</span><br><span class="line">            - NULL : 永久阻塞,直到检测到了文件描述符有变化</span><br><span class="line">            - tv_sec = 0 tv_usec = 0, 不阻塞</span><br><span class="line">            - tv_sec &gt; 0 tv_usec &gt; 0, 阻塞对应的时间</span><br><span class="line">    - 返回值 :</span><br><span class="line">        - -1 : 失败</span><br><span class="line">        - &gt;0(n) : 检测的集合中有n个文件描述符发生了变化 </span><br><span class="line">*/</span><br><span class="line">// 将参数文件描述符fd对应的标志位设置为0</span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">// 判断fd对应的标志位是0还是1, 返回值 : fd对应的标志位的值,0,返回0, 1,返回1</span><br><span class="line">int FD_ISSET(int fd, fd_set *set);</span><br><span class="line">// 将参数文件描述符fd 对应的标志位,设置为1</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">// fd_set一共有1024 bit, 全部初始化为0</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br></pre></td></tr></table></figure><h3 id="select-代码编写"><a href="#select-代码编写" class="headerlink" title="select 代码编写"></a>select 代码编写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    struct sockaddr_in saddr;</span><br><span class="line">    saddr.sin_port = htons(9999);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr));</span><br><span class="line">    listen(lfd, 8);</span><br><span class="line"></span><br><span class="line">    // tmp 是内核返回的，rdset 是我们操作的（不要直接操作内核）</span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    int maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = rdset;</span><br><span class="line"></span><br><span class="line">        int ret = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;select&quot;);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有任何改变，因此可以不执行什么操作</span><br><span class="line">        else if (ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 说明检测到了缓冲区变化</span><br><span class="line">        else if (ret &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // 如果是 lfd 发生改变了，那么就说明建立的新的连接</span><br><span class="line">            if (FD_ISSET(lfd, &amp;tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in clinaddr;</span><br><span class="line">                int len = sizeof(clinaddr);</span><br><span class="line">                int cfd = accept(lfd, (struct sockaddr *)&amp;clinaddr, &amp;len);</span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 遍历所有的 cfd ，如果有更改，那么就和它通信</span><br><span class="line">            for (int i = lfd + 1; i &lt;= maxfd; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (FD_ISSET(i, &amp;tmp))</span><br><span class="line">                &#123;</span><br><span class="line">                    char buf[1024] = &#123;0&#125;;</span><br><span class="line">                    int len = read(i, buf, sizeof(buf));</span><br><span class="line">                    if (len == -1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(&quot;read&quot;);</span><br><span class="line">                        exit(-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 断开通信了</span><br><span class="line">                    else if (len == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;client closed...\n&quot;);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 通信，先读再写</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;read buf = %s\n&quot;, buf);</span><br><span class="line">                        write(i, buf, strlen(buf) + 1);</span><br><span class="line">                        memset(buf, 0, sizeof(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><a href="https://image.ceyewan.top/typora/image-20220721135911567.png"><img src="https://image.ceyewan.top/typora/image-20220721135911567.png" alt="image-20220721135911567"></a></p><h3 id="poll-API-介绍及代码编写"><a href="#poll-API-介绍及代码编写" class="headerlink" title="poll API 介绍及代码编写"></a>poll API 介绍及代码编写</h3><p>select 是有一个遍历的，并且还有 fdset 从用户态拷贝到内核态，并且 select 支持的文件描述符数量太少了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* 委托内核检测的文件描述符 */</span><br><span class="line">    short events; /* 委托内核检测文件描述符的什么事件 */</span><br><span class="line">    short revents; /* 文件描述符实际发生的事件 */</span><br><span class="line">&#125;;</span><br><span class="line">struct pollfd myfd;</span><br><span class="line">myfd.fd = 5;</span><br><span class="line">myfd.events = POLLIN | POLLOUT; // 读事件和写事件</span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">- 参数:</span><br><span class="line">    - fds : 是一个struct pollfd 结构体数组,这是一个需要检测的文件描述符的集合</span><br><span class="line">    - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1</span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">        0 : 不阻塞</span><br><span class="line">        -1 : 阻塞,当检测到需要检测的文件描述符有变化,解除阻塞</span><br><span class="line">        &gt;0 : 阻塞的时长</span><br><span class="line">- 返回值:</span><br><span class="line">    -1 : 失败</span><br><span class="line">    &gt;0(n) : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><p>和 select 的区别在于，自行指定大小，并且分离了内核区和用户区，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    struct sockaddr_in saddr;</span><br><span class="line">    saddr.sin_port = htons(9999);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr));</span><br><span class="line">    listen(lfd, 8);</span><br><span class="line"></span><br><span class="line">    struct pollfd fds[1024];</span><br><span class="line">    for (int i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = -1;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[0].fd = lfd;</span><br><span class="line">    int nfds = 0;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        int ret = poll(fds, nfds + 1, -1);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;poll&quot;);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有任何改变，因此可以不执行什么操作</span><br><span class="line">        else if (ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 说明检测到了缓冲区变化</span><br><span class="line">        else if (ret &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // 如果是 lfd 发生改变了，那么就说明建立的新的连接</span><br><span class="line">            if (fds[0].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in clinaddr;</span><br><span class="line">                int len = sizeof(clinaddr);</span><br><span class="line">                int cfd = accept(lfd, (struct sockaddr *)&amp;clinaddr, &amp;len);</span><br><span class="line">                for (int i = 1; i &lt; 1024; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (fds[i].fd == -1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 遍历所有的 cfd ，如果有更改，那么就和它通信</span><br><span class="line">            for (int i = 1; i &lt;= nfds; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (fds[i].revents &amp; POLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                    char buf[1024] = &#123;0&#125;;</span><br><span class="line">                    int len = read(fds[i].fd, buf, sizeof(buf));</span><br><span class="line">                    if (len == -1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(&quot;read&quot;);</span><br><span class="line">                        exit(-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 断开通信了</span><br><span class="line">                    else if (len == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;client closed...\n&quot;);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 通信，先读再写</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;read buf = %s\n&quot;, buf);</span><br><span class="line">                        write(fds[i].fd, buf, strlen(buf) + 1);</span><br><span class="line">                        memset(buf, 0, sizeof(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-API-介绍"><a href="#epoll-API-介绍" class="headerlink" title="epoll API 介绍"></a>epoll API 介绍</h3><p>就是 poll 的优化版本，poll 之间用个数组，太低效了，因此 epoll 使用的是红黑树，插入和删除效率更高，并且直接返回哪几个而不是几个，省去了一次遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">// 创建一个新的epoll实例。在内核中创建了一个数据,这个数据中有两个比较重要的数据,一个是需要检测的文件描述符的信息(红黑树),还有一个是就绪列表,存放检测到数据发送改变的文件描述符信息(双向链表)。</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">- 参数:</span><br><span class="line">    size : 目前没有意义了。随便写一个数,必须大于0</span><br><span class="line">- 返回值:</span><br><span class="line">    -1 : 失败</span><br><span class="line">    &gt; 0 : 文件描述符,操作epoll实例的</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void *ptr;</span><br><span class="line">    int fd;</span><br><span class="line">    uint32_t u32;</span><br><span class="line">    uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t events; /* Epoll events */</span><br><span class="line">    epoll_data_t data;/* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件:</span><br><span class="line">- EPOLLIN</span><br><span class="line">- EPOLLOUT</span><br><span class="line">- EPOLLERR</span><br><span class="line">- EPOLLET （ET 模式）</span><br><span class="line">// 对epoll实例进行管理:添加文件描述符信息,删除信息,修改信息</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">- 参数:</span><br><span class="line">    - epfd : epoll实例对应的文件描述符</span><br><span class="line">    - op : 要进行什么操作</span><br><span class="line">        EPOLL_CTL_ADD:添加</span><br><span class="line">        EPOLL_CTL_MOD:修改</span><br><span class="line">        EPOLL_CTL_DEL:删除</span><br><span class="line">    - fd : 要检测的文件描述符</span><br><span class="line">    - event : 检测文件描述符什么事情</span><br><span class="line">// 检测函数</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line">- 参数:</span><br><span class="line">    - epfd : epoll实例对应的文件描述符</span><br><span class="line">    - events : 传出参数,保存了发送了变化的文件描述符的信息</span><br><span class="line">    - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">    - timeout : 阻塞时间</span><br><span class="line">        - 0 : 不阻塞</span><br><span class="line">        - -1 : 阻塞,直到检测到fd数据发生变化,解除阻塞</span><br><span class="line">        - &gt; 0 : 阻塞的时长(毫秒)</span><br><span class="line">- 返回值:</span><br><span class="line">    - 成功,返回发送变化的文件描述符的个数 &gt; 0</span><br><span class="line">    - 失败 -1        </span><br></pre></td></tr></table></figure><h3 id="epoll-代码编写"><a href="#epoll-代码编写" class="headerlink" title="epoll 代码编写"></a>epoll 代码编写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    struct sockaddr_in saddr;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(9999);</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr));</span><br><span class="line"></span><br><span class="line">    listen(lfd, 8);</span><br><span class="line"></span><br><span class="line">    int epfd = epoll_create(1000);</span><br><span class="line"></span><br><span class="line">    struct epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    struct epoll_event epevs[1024];</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        int ret = epoll_wait(epfd, epevs, 1024, -1);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;epoll_wait&quot;);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;ret = %d\n&quot;, ret);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; ret; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            if (curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                int len = sizeof(cliaddr);</span><br><span class="line">                int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (epevs[i].events &amp; EPOLLOUT)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                char buf[1024] = &#123;0&#125;;</span><br><span class="line">                int len = read(curfd, buf, sizeof(buf));</span><br><span class="line">                if (len == -1)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;read&quot;);</span><br><span class="line">                    exit(-1);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (len == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;client closed...\n&quot;);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;read buf = %s\n&quot;, buf);</span><br><span class="line">                    write(curfd, buf, strlen(buf) + 1);</span><br><span class="line">                    memset(buf, 0, sizeof(buf));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-的两种工作模式"><a href="#epoll-的两种工作模式" class="headerlink" title="epoll 的两种工作模式"></a>epoll 的两种工作模式</h3><ul><li>LT 模式（水平触发）<ul><li>默认的工作方式，支持阻塞和非阻塞。内核告诉你一个文件描述符就绪了，如果不作任何操作，内核还是会继续通知你。</li></ul></li><li>ET 模式（边沿触发）<ul><li>是一种高速工作模式。只支持非阻塞，只会在文件描述符发生改变时才会通知。减少了 epoll 被触发的次数。</li></ul></li></ul><h3 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h3><p>服务器：</p><blockquote><p>socket() -&gt; bind() -&gt; recvfrom() -&gt; sendto() -&gt; close()</p></blockquote><p>客户端：</p><blockquote><p>socket() -&gt; recvfrom() -&gt; sendto() -&gt; close()</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">- 参数:</span><br><span class="line">    - sockfd : 通信的fd</span><br><span class="line">    - buf : 要发送的数据</span><br><span class="line">    - len : 发送数据的长度</span><br><span class="line">    - flags : 0</span><br><span class="line">    - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">    - addrlen : 地址的内存大小</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line">- 参数:</span><br><span class="line">    - sockfd : 通信的fd</span><br><span class="line">    - buf : 接收数据的数组</span><br><span class="line">    - len : 数组的大小</span><br><span class="line">    - flags : 0</span><br><span class="line">    - src_addr : 用来保存另外一端的地址信息,不需要可以指定为NULL</span><br><span class="line">    - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure><h3 id="广播和组播"><a href="#广播和组播" class="headerlink" title="广播和组播"></a>广播和组播</h3><p>广播：</p><blockquote><p>向子网中多台计算机发送消息,并且子网中所有的计算机都可以接收到发送方发送的消息,每个广播消息都包含一个特殊的 IP 地址,这个 IP 中子网内主机标志部分的二进制全部为1。</p><ol><li>只能在局域网中使用。</li><li>客户端需要绑定服务器广播使用的端口,才可以接收到广播消息。</li></ol></blockquote><p>组播：</p><blockquote><p>单播地址标识单个 IP 接口,广播地址标识某个子网的所有 IP 接口,多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端(要么单个要么全部),多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收,也就是说由运行相应多播会话应用系统的主机上的接口接收。另外,广播一般局限于局域网内使用,而多播则既可以用于局域网,也可以跨广域网使用。</p><ol><li>组播既可以用于局域网,也可以用于广域网</li><li>客户端需要加入多播组,才能接收到多播的数据</li></ol></blockquote><h3 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h3><p>本地进程间的通信，是稍微简化了的 tcp 通信。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">// 本地套接字通信的流程 - tcp</span><br><span class="line">// 服务器端</span><br><span class="line">1. 创建监听的套接字</span><br><span class="line">int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);</span><br><span class="line">2. 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line">struct sockaddr_un addr;</span><br><span class="line">// 绑定成功之后,指定的sun_path中的套接字文件会自动生成。</span><br><span class="line">bind(lfd, addr, len);</span><br><span class="line">3. 监听</span><br><span class="line">listen(lfd, 100);</span><br><span class="line">4. 等待并接受连接请求</span><br><span class="line">struct sockaddr_un cliaddr;</span><br><span class="line">int cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line">5. 通信</span><br><span class="line">接收数据:read/recv</span><br><span class="line">发送数据:write/send</span><br><span class="line">6. 关闭连接</span><br><span class="line">close();</span><br><span class="line">// 客户端的流程</span><br><span class="line">1. 创建通信的套接字</span><br><span class="line">int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);</span><br><span class="line">2. 监听的套接字绑定本地的IP 端口</span><br><span class="line">struct sockaddr_un addr;</span><br><span class="line">// 绑定成功之后,指定的sun_path中的套接字文件会自动生成。</span><br><span class="line">bind(lfd, addr, len);</span><br><span class="line">3. 连接服务器</span><br><span class="line">struct sockaddr_un serveraddr;</span><br><span class="line">connect(fd, &amp;serveraddr, sizeof(serveraddr));</span><br><span class="line">4. 通信</span><br><span class="line">接收数据:read/recv</span><br><span class="line">发送数据:write/send</span><br><span class="line">5. 关闭连接</span><br><span class="line">close();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;I-x2F-O-多路复用&quot;&gt;&lt;a href=&quot;#I-x2F-O-多路复用&quot; class=&quot;headerlink&quot; title=&quot;I&amp;#x2F;O 多路复用&quot;&gt;&lt;/a&gt;I&amp;#x2F;O 多路复用&lt;/h3&gt;&lt;p&gt;主要目的是为了使得程序能同时监听多个文件描述符，能够提高</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程（一）</title>
    <link href="http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-12-16T11:22:50.000Z</published>
    <updated>2022-12-16T11:26:08.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络结构模式"><a href="#网络结构模式" class="headerlink" title="网络结构模式"></a>网络结构模式</h3><h4 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h4><p>服务器-客户机，即 Client - Server 结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。</p><p>优点：</p><ul><li>能充分发挥客户端 PC 的处理能力，响应速度快。</li><li>安全性较高。</li></ul><p>缺点：</p><ul><li>客户端需要安装专用的客户端软件</li><li>对客户端的操作系统一般也会有限制，不能跨平台</li></ul><h4 id="B-x2F-S结构"><a href="#B-x2F-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h4><p>浏览器 - 服务端，即 Browser - Server 模式。</p><p>优点：</p><ul><li>总体成本低，维护方便，分布性强，开发简单</li></ul><p>缺点：</p><ul><li>通信开销大</li><li>协议固定，http&#x2F;https</li><li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度降低</li></ul><h3 id="MAC地址、IP地址、端口"><a href="#MAC地址、IP地址、端口" class="headerlink" title="MAC地址、IP地址、端口"></a>MAC地址、IP地址、端口</h3><ul><li>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，每个网卡都有一个独一无二的称为 MAC 地址的号码。</li><li>MAC 地址，也称为局域网地址、以太网地址，是一个用来确定网络设备位置的地址，在生产时确定。</li><li>IP 协议是为计算机网络相互连接进行通信而设计的协议。</li><li>IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式。点分十进制的 32 位二进制数。</li><li>子网掩码，是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。作用就是将某个 IP 地址划分为网络地址和主机地址。</li><li>端口是设备与外界通讯交流的出口。因为一个设备和外界可能同时有很多交流，因此需要很多端口来分别处理。</li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="OSI-七层参考模型"><a href="#OSI-七层参考模型" class="headerlink" title="OSI 七层参考模型"></a>OSI 七层参考模型</h4><table><thead><tr><th>OSI 参考模型</th><th>各层的解释</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务</td></tr><tr><td>表示层</td><td>数据格式转化</td></tr><tr><td>会话层</td><td>建立、管理和维护会话</td></tr><tr><td>传输层</td><td>建立、管理和维护端到端的连接</td></tr><tr><td>网络层</td><td>IP 地址及路由选择</td></tr><tr><td>数据链路层</td><td>提供介质访问和链路管理</td></tr><tr><td>物理层</td><td>主要定义物理设备标准，作用是传输比特流（数模转换）</td></tr></tbody></table><h4 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h4><p>TCP&#x2F;IP协议族是一个分层、多协议的通信体系，是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用<br>层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p><table><thead><tr><th>层次</th><th>作用</th></tr></thead><tbody><tr><td>应用层</td><td>直接为应用进程提供服务的</td></tr><tr><td>传输层</td><td>TCP&#x2F;UDP 协议</td></tr><tr><td>网络层</td><td>进行网络连接的建立和终止以及 IP 地址的寻找等功能。</td></tr><tr><td>网路接口层（数据链路层+物理层）</td><td>网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。</td></tr></tbody></table><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>网络协议是通信计算机双方必须共同遵从的一组约定。</p><ul><li>应用层：HTTP 协议（超文本传输协议）、FTP 协议（文件传输协议）</li><li>传输层：TCP 协议（传输控制协议）、UDP 协议（用户数据报协议）</li><li>网络层：IP 协议（因特网互联协议）</li><li>网络接口层：ARP 协议（地址解析协议）、RARP 协议（反向地址解析协议）</li></ul><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p>16 位源端口号 + 16 位目的端口号 + 16 位 UDP 长度 + 16 位 UDP 检验和 + 数据。头部一共 8 字节。</p><h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p><a href="https://image.ceyewan.top/typora/image-20221027163026360.png"><img src="https://image.ceyewan.top/typora/image-20221027163026360.png" alt="image-20221027163026360"></a></p><ol><li>序列号：本报文段的数据的第一个字节的序号</li><li>确认序号：期望收到对方下一个报文段的第一个数据字节的序号</li><li>首部长度(数据偏移):TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远,即首部长度。单位:32位,即以 4 字节为计算单位</li></ol><h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p><a href="https://image.ceyewan.top/typora/image-20221027163451383.png"><img src="https://image.ceyewan.top/typora/image-20221027163451383.png" alt="image-20221027163451383"></a></p><ol><li>版本号：IP 协议的版本，当前使用最广泛的是 4（IPv4）</li><li>生存时间：每经过一个路由器转发，就把 TTL 的大小减少 1</li></ol><h3 id="封装和分用"><a href="#封装和分用" class="headerlink" title="封装和分用"></a>封装和分用</h3><p>应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用。</p><h3 id="socket-介绍"><a href="#socket-介绍" class="headerlink" title="socket 介绍"></a>socket 介绍</h3><p>socket 套接字，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。</p><p>socket 本身有”插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>现代 CPU 的累加器一次都能装载(至少) 4 字节(这里考虑 32 位机)，即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。</p><p>大端序：一个整数的最高位字节存储在内存的低地址处，低位字节在内存的高位地址中。（02 00 00 00 表示 2）</p><p>小端序：一个整数的最高位字节存储在内存的高地址处，低位字节在内存的低位地址中。</p><p>发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换(小端机转换，大端机不转换)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">// h host 主机 主机字节序</span><br><span class="line">// n network 网络字节序</span><br><span class="line"></span><br><span class="line">// 转换端口</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint16_t ntohs(uint16_t hostshort);</span><br><span class="line">// 转 IP</span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br></pre></td></tr></table></figure><h3 id="socket-地址"><a href="#socket-地址" class="headerlink" title="socket 地址"></a>socket 地址</h3><p>socket地址其实是一个结构体，封装端口号和 IP 等信息。</p><h4 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h4><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include&lt;bits/socket.h&gt;</span><br><span class="line"></span><br><span class="line">struct sockaddr &#123;</span><br><span class="line">sa_family_t sa_family;</span><br><span class="line">char sa_data[14];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef unsigned short int sa_family_t;</span><br></pre></td></tr></table></figure><p>sa_family 成员是地址族类型变量，与协议族类型对应（PF_INET 表示 IPv4 协议，PF_INET6 表示 IPv6 协议族）。</p><p>sa_data 成员用于存放 socket 地址值。</p><h4 id="专用-socket-地址"><a href="#专用-socket-地址" class="headerlink" title="专用 socket 地址"></a>专用 socket 地址</h4><p>sockaddr_in 和 sockaddr_in6 方便我们操作，然后统一为 sockaddr 使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">    sa_family_t sin_family;</span><br><span class="line">    in_port_t sin_port; /* Port number.*/</span><br><span class="line">    struct in_addr sin_addr; /* Internet address.*/</span><br><span class="line">    unsigned char xxx; // 用来和 struct sockaddr 保持大小相等的</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr</span><br><span class="line">&#123;</span><br><span class="line">in_addr_t s_addr;</span><br><span class="line">&#125;;</span><br><span class="line">struct sockaddr_in6</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sin6_family;</span><br><span class="line">in_port_t sin6_port; /* Transport layer port # */</span><br><span class="line">    uint32_t sin6_flowinfo; /* IPv6 flow information */</span><br><span class="line">    struct in6_addr sin6_addr; /* IPv6 address */</span><br><span class="line">    uint32_t sin6_scope_id; /* IPv6 scope-id */</span><br><span class="line">&#125;;</span><br><span class="line">typedef unsigned short uint16_t;</span><br><span class="line">typedef unsigned int uint32_t;</span><br><span class="line">typedef uint16_t in_port_t;</span><br><span class="line">typedef uint32_t in_addr_t;</span><br><span class="line">#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span><br></pre></td></tr></table></figure><h3 id="IP-地址转换"><a href="#IP-地址转换" class="headerlink" title="IP 地址转换"></a>IP 地址转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line"> /*af: 地址族 AF_INET、AF_INET6</span><br><span class="line"> src: 需要转换的点分十进制的 ip字符串</span><br><span class="line"> dst: 转化后的结果*/</span><br><span class="line"> </span><br><span class="line">const char *inet_ntop(int af, void *src, char *dst, socklen_t size);</span><br><span class="line"> /*size: 第三个参数的大小</span><br><span class="line"> 返回值：和 dst 是同一个值*/</span><br></pre></td></tr></table></figure><h3 id="TCP-通信流程"><a href="#TCP-通信流程" class="headerlink" title="TCP 通信流程"></a>TCP 通信流程</h3><ul><li>TCP：传输控制协议、面向连接的、可靠的、基于字节流</li></ul><p>服务器端：</p><ol><li>创建一个用于监听的套接字（socket() 函数）<ul><li>监听：监听有客户端的连接</li><li>套接字：这个套接字其实就是一个文件描述符</li></ul></li><li>将这个监听文件描述符和本地的 IP 和端口绑定（bind() 函数）<ul><li>客户连接服务器的时候使用的就是这个 IP 和端口</li></ul></li><li>设置监听，监听的 fd 开始工作（listen() 函数）</li><li>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（accept() 函数）</li><li>通信<ul><li>接收数据（recv() 函数）</li><li>发送数据（send() 函数）</li></ul></li><li>通信结束，断开连接（close() 函数）</li></ol><p>客户端：</p><ol><li>创建一个用于通信的套接字（socket() 函数）</li><li>连接服务器，需要指定连接的服务器的 IP 和端口（connect() 函数）</li><li>连接成功了，客户端可以直接和服务端通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束，断开连接</li></ol><h3 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt; // 包含了这个头文件,上面两个就可以省略</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">- 功能:创建一个套接字</span><br><span class="line">- 参数:</span><br><span class="line">- domain: 协议族</span><br><span class="line">AF_INET : ipv4</span><br><span class="line">AF_INET6 : ipv6</span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信(进程间通信)</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">SOCK_STREAM : 流式协议</span><br><span class="line">SOCK_DGRAM : 报式协议</span><br><span class="line">- protocol : 具体的一个协议。一般写 0</span><br><span class="line">- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值:</span><br><span class="line">- 成功:返回文件描述符,操作的就是内核缓冲区。</span><br><span class="line">- 失败:-1</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); </span><br><span class="line">- 功能:绑定,将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址,这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">- 功能:监听这个socket上的连接</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值, 5</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">- 功能:接收客户端连接,默认是一个阻塞的函数,阻塞等待客户端连接</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数,记录了连接成功后客户端的地址信息(ip,port)</span><br><span class="line">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值:</span><br><span class="line">- 成功 :用于通信的文件描述符</span><br><span class="line">- -1 : 失败</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">- 功能: 客户端连接服务器</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd : 用于通信的文件描述符</span><br><span class="line">- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值:成功 0, 失败 -1</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count); // 写数据</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count); // 读数据</span><br></pre></td></tr></table></figure><h3 id="TCP-通信实现"><a href="#TCP-通信实现" class="headerlink" title="TCP 通信实现"></a>TCP 通信实现</h3><ol><li>服务端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个套接字</span><br><span class="line">    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    /*</span><br><span class="line">        AF_INET 表示使用 IPv4 地址</span><br><span class="line">        SOCK_STREAM 表示使用面向连接的套接字</span><br><span class="line">        IPPROTO_TCP 表示使用 TCP 协议</span><br><span class="line">        socket 也是一个文件，返回文件描述符，可以当初文件来操作</span><br><span class="line">    */</span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    serv_addr.sin_port = htons(1234);</span><br><span class="line"></span><br><span class="line">    // 将套接字与特定的 IP 地址和端口绑定。流经这个 IP 和端口的数据交给套接字处理</span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">    // 被动监听，睡眠直到客户端发起请求，第二个参数为请求队列的最大长度</span><br><span class="line">    listen(serv_sock, 20);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clnt_addr;</span><br><span class="line">    socklen_t clnt_addr_size = sizeof(clnt_addr);</span><br><span class="line">    // 用来接收客户端的请求，返回客户端的套接字</span><br><span class="line">    int clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    // 向套接字文件中写入数据</span><br><span class="line">    char str[] = &quot;Hello Socket World&quot;;</span><br><span class="line">    write(clnt_sock, str, sizeof(str));</span><br><span class="line"></span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>客户端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_addr));           //每个字节都用0填充</span><br><span class="line">    serv_addr.sin_family = AF_INET;                     //使用IPv4地址</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //具体的IP地址</span><br><span class="line">    serv_addr.sin_port = htons(1234);                   //端口</span><br><span class="line">    // 向服务器发起请求，服务器的 IP 地址和端口号保存在 sockaddr_in 结构体中</span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">    //读取服务器传回的数据</span><br><span class="line">    char buffer[40];</span><br><span class="line">    read(sock, buffer, sizeof(buffer) - 1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Message form server: %s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">    //关闭套接字</span><br><span class="line">    close(sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP-三次握手四次挥手"><a href="#TCP-三次握手四次挥手" class="headerlink" title="TCP 三次握手四次挥手"></a>TCP 三次握手四次挥手</h3><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。</p><p>滑动窗口(Sliding window)是一种流量控制技术。早期的网络通信中,通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况,同时发送数据,导致中间节点阻塞掉包,谁也发不了数据,所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术,即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包(称窗口尺寸)。</p><p>TCP 中采用滑动窗口来进行传输控制,滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时,发送方一般不能再发送数据报。</p><p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p><p>四次挥手：</p><p><a href="https://image.ceyewan.top/typora/10093416_62a29f98950cf57199.png"><img src="https://image.ceyewan.top/typora/10093416_62a29f98950cf57199.png" alt="img"></a></p><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><ul><li>防止服务器重启时之前绑定的端口还没释放</li><li>程序突然退出而系统没有释放端口</li></ul><h3 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h3><ol><li>服务端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个套截字</span><br><span class="line">    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    /*</span><br><span class="line">        AF_INET 表示使用 IPv4 地址</span><br><span class="line">        SOCK_STREAM 表示使用面向连接的套接字</span><br><span class="line">        IPPROTO_TCP 表示使用 TCP 协议</span><br><span class="line">        socket 也是一个文件，返回文件描述符，可以当初文件来操作</span><br><span class="line">    */</span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    serv_addr.sin_port = htons(9999);</span><br><span class="line"></span><br><span class="line">    // 将套接字与特定的 IP 地址和端口绑定。流经这个 IP 和端口的数据交给套接字处理</span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">    // 被动监听，睡眠直到客户端发起请求，第二个参数为请求队列的最大长度</span><br><span class="line">    listen(serv_sock, 20);</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        struct sockaddr_in clnt_addr;</span><br><span class="line">        socklen_t clnt_addr_size = sizeof(clnt_addr);</span><br><span class="line">        // 用来接收客户端的请求，返回客户端的套接字</span><br><span class="line">        int clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            char buffer[1024];</span><br><span class="line">            while (1)</span><br><span class="line">            &#123;</span><br><span class="line">                memset(buffer, 0, sizeof(buffer));</span><br><span class="line">                int len = read(clnt_sock, buffer, 1024);</span><br><span class="line">                if (len == -1)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                write(clnt_sock, buffer, strlen(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>客户端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_addr));           //每个字节都用0填充</span><br><span class="line">    serv_addr.sin_family = AF_INET;                     //使用IPv4地址</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //具体的IP地址</span><br><span class="line">    serv_addr.sin_port = htons(9999);                   //端口</span><br><span class="line">    // 向服务器发起请求，服务器的 IP 地址和端口号保存在 sockaddr_in 结构体中</span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">    //读取服务器传回的数据</span><br><span class="line">    char buffer[40];</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf(buffer, &quot;client send %d&quot;, i++);</span><br><span class="line">        write(sock, buffer, strlen(buffer));</span><br><span class="line">        memset(buffer, 0, sizeof(buffer));</span><br><span class="line">        sleep(1);</span><br><span class="line">        read(sock, buffer, sizeof(buffer) - 1);</span><br><span class="line">        printf(&quot;Message form server: %s\n&quot;, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭套接字</span><br><span class="line">    close(sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行结果</li></ol><p><a href="https://image.ceyewan.top/typora/image-20220718230913449.png"><img src="https://image.ceyewan.top/typora/image-20220718230913449.png" alt="image-20220718230913449"></a></p><h3 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h3><p>只需要修改服务端，在创建进程的地方创建线程即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">void *myserve(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int clnt_sock = *(int *)arg;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(buffer, 0, sizeof(buffer));</span><br><span class="line">        int len = read(clnt_sock, buffer, 1024);</span><br><span class="line">        if (len == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        write(clnt_sock, buffer, strlen(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个套截字</span><br><span class="line">    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    /*</span><br><span class="line">        AF_INET 表示使用 IPv4 地址</span><br><span class="line">        SOCK_STREAM 表示使用面向连接的套接字</span><br><span class="line">        IPPROTO_TCP 表示使用 TCP 协议</span><br><span class="line">        socket 也是一个文件，返回文件描述符，可以当初文件来操作</span><br><span class="line">    */</span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_ad);dr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    serv_addr.sin_port = htons(9999);</span><br><span class="line"></span><br><span class="line">    // 将套接字与特定的 IP 地址和端口绑定。流经这个 IP 和端口的数据交给套接字处理</span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">    // 被动监听，睡眠直到客户端发起请求，第二个参数为请求队列的最大长度</span><br><span class="line">    listen(serv_sock, 20);</span><br><span class="line">    int i = 0;</span><br><span class="line">    pthread_t pid[20];</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        struct sockaddr_in clnt_addr;</span><br><span class="line">        socklen_t clnt_addr_size = sizeof(clnt_addr);</span><br><span class="line">        // 用来接收客户端的请求，返回客户端的套接字</span><br><span class="line">        int *clnt_sock = (int *)malloc(sizeof(int));</span><br><span class="line">        *clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">        pthread_create(&amp;pid[(i++) % 20], NULL, myserve, (void *)clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络结构模式&quot;&gt;&lt;a href=&quot;#网络结构模式&quot; class=&quot;headerlink&quot; title=&quot;网络结构模式&quot;&gt;&lt;/a&gt;网络结构模式&lt;/h3&gt;&lt;h4 id=&quot;C-x2F-S结构&quot;&gt;&lt;a href=&quot;#C-x2F-S结构&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多进程开发（三）</title>
    <link href="http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-12-16T11:19:56.000Z</published>
    <updated>2022-12-16T11:22:38.045Z</updated>
    
    <content type="html"><![CDATA[<p>本节和<a href="https://www.ceyewan.top/p/695d7f82.html">【OSTEP】并发</a>部分的内容大体一致。</p><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><p>与进程类似，线程是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。</p><p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</p><p>线程是轻量级进程（LWP：Light Wight Process），在 Linux 环境下线程的本质任是进程。</p><p>查看指定进程的 LWP 号：<code>ps -Lf pid</code></p><p>进程间的信息难以共享，进程通信较难；调用 fork() 来创建进程的代价相对较高。而线程通过共享解决了这些问题。</p><p>线程之间的共享和非共享资源</p><ul><li>共享资源：进程 ID 和父进程 ID，进程组 ID 和会话 ID，用户 ID 和用户组 ID，文件描述符，信号处理，文件系统的相关信息，虚拟地址空间（除栈和 <code>.text</code>）。</li><li>非共享资源：线程 ID，信号掩码，线程特有数据，error 变量，实时调度策略和优先级，栈、本地变量和函数的调用链接信息</li></ul><p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</span><br><span class="line">// 参数1：pthread_t *thread：传递一个 pthread_t 类型的指针变量 or 地址</span><br><span class="line">// 参数2：const pthread_attr_t *attr：用于手动设置新建线程的属性</span><br><span class="line">// 例如线程的调用策略、线程所能使用的栈内存的大小等。默认为 NULL</span><br><span class="line">// 参数3：void *(*start_routine) (void *)：以函数指针的方式指明新建线程需要执行的函数</span><br><span class="line">// 该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。</span><br><span class="line">// void *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可</span><br><span class="line">// 成功：返回 0 ;失败返回错误号，调用 char *strerror(int errornum) 查看</span><br></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">void pthread_exit(void *retval);</span><br><span class="line">// 终止一个线程，在哪个线程中调用，就表示终止哪个线程，终止主线程不会影响子线程</span><br><span class="line">// 传递一个指针，作为一个返回值</span><br><span class="line">// 子线程 return NULL 等价与 pthread_exit(NULL)</span><br><span class="line">pthread_t pthread_self();</span><br><span class="line">// 获取线程的 id</span><br></pre></td></tr></table></figure><h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">// 功能，和一个已经终止的线程进行连接，回收子线程的资源，是阻塞函数，retval 用于获取子线程的返回值</span><br></pre></td></tr></table></figure><h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int pthread_detch(pthread_t thread);</span><br><span class="line">// 分离一个线程，当一个线程分离后，终止后资源会自动释放</span><br><span class="line">// 不能多次分离，否则会有 undefined behave </span><br></pre></td></tr></table></figure><h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line">// 取消线程，让线程终止，但并不是马上终止，而是子进程执行到取消点时</span><br><span class="line">// 取消点可以理解为系统调用时</span><br></pre></td></tr></table></figure><p>一个小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int ticket = 100;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void *sellticket(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        if (ticket &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%ld sell the %d ticket\n&quot;, pthread_self(), ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(5000);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">    pthread_t pid[3];</span><br><span class="line">    int rc = pthread_create(&amp;pid[0], NULL, sellticket, NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    rc = pthread_create(&amp;pid[1], NULL, sellticket, NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    rc = pthread_create(&amp;pid[2], NULL, sellticket, NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    // 方法一，阻塞</span><br><span class="line">    rc = pthread_join(pid[0], NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    rc = pthread_join(pid[1], NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    rc = pthread_join(pid[2], NULL);</span><br><span class="line">    assert(rc == 0);</span><br><span class="line">    // 方法二，不阻塞</span><br><span class="line">    // rc = pthread_detach(pid[0]);</span><br><span class="line">    // assert(rc == 0);</span><br><span class="line">    // rc = pthread_detach(pid[1]);</span><br><span class="line">    // assert(rc == 0);</span><br><span class="line">    // rc = pthread_detach(pid[2]);</span><br><span class="line">    // assert(rc == 0);</span><br><span class="line">    // 方法三，不阻塞</span><br><span class="line">    // pthread_exit(NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// 初始化线程属性变量</span><br><span class="line">int pthread_attr_init(pthread_attr_t *attr);</span><br><span class="line">// 释放线程属性的资源</span><br><span class="line">int pthread_attr_destroy(pthread_attr_t *attr);</span><br><span class="line">// 设置线程分离的状态属性</span><br><span class="line">int pthread_addr_setdetachstate(const pthread_attr_t *attr, int detachstate);</span><br><span class="line">// 获取线程分离的状态属性</span><br><span class="line">int pthread_addr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span><br></pre></td></tr></table></figure><p>剩下的完全一样，没必要浪费时间了。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本节和&lt;a href=&quot;https://www.ceyewan.top/p/695d7f82.html&quot;&gt;【OSTEP】并发&lt;/a&gt;部分的内容大体一致。&lt;/p&gt;
&lt;h3 id=&quot;线程概述&quot;&gt;&lt;a href=&quot;#线程概述&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多进程开发（二）</title>
    <link href="http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-12-16T11:14:22.000Z</published>
    <updated>2022-12-16T11:19:13.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射是将磁盘文件中的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">/*- 功能：将一个文件或设备的数据映射到内存中</span><br><span class="line">- addr：一般为 NULL ，又内核决定</span><br><span class="line">- length：要映射的数据的长度，建议用文件长度（获取文件的长度：stat、lseek</span><br><span class="line">- prot：对申请的内存映射区的操作权限（PROT_READ(读)、PROT_WRITE(写）...）</span><br><span class="line">- flags：MAP_SHARED:映射区的文件会自动和磁盘文件同步</span><br><span class="line">MAP_PRIVATE:不同步，互不影响</span><br><span class="line">- fd 需要映射的那个文件的文件描述符，文件大于 0 ，open 的参数不能和 prot 冲突</span><br><span class="line">- 文件描述符的偏移量，必须是 4k 的整数倍，一般为 0</span><br><span class="line">- 返回值为创建的内存的首地址</span><br><span class="line">*/</span><br><span class="line">int munmap(void *addr, size_t length);</span><br><span class="line">/* - addr 要释放的内存的首地址</span><br><span class="line">- length 要释放的内存的长度</span><br></pre></td></tr></table></figure><p>内存映射区通信式非阻塞的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#define LENGTH 4096</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int fd = open(&quot;file.txt&quot;, O_RDWR | O_CREAT);</span><br><span class="line">    assert(fd != -1);</span><br><span class="line">    // int rc = truncate(&quot;file.txt&quot;, LENGTH);</span><br><span class="line">    int rc = lseek(fd, LENGTH, SEEK_END);</span><br><span class="line">    assert(rc != -1);</span><br><span class="line">    void *addr = mmap(NULL, LENGTH, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    int pid = fork();</span><br><span class="line">    assert(pid != -1);</span><br><span class="line">    if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy((char *)addr, &quot;Hello father process.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rc = wait(NULL);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        printf(&quot;%s&quot;, (char *)addr);</span><br><span class="line">    &#125;</span><br><span class="line">    rc = munmap(addr, LENGTH);</span><br><span class="line">    assert(rc != -1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名映射：不需要文件实体进行一个内存映射。只能用于有亲缘关系的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#define LENGTH 4096</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void *addr = mmap(NULL, LENGTH, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    int pid = fork();</span><br><span class="line">    assert(pid != -1);</span><br><span class="line">    if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        char *ret = strcpy((char *)addr, &quot;Hello father process.\n&quot;);</span><br><span class="line">        assert(ret != NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int rc = wait(NULL);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        printf(&quot;%s&quot;, (char *)addr);</span><br><span class="line">    &#125;</span><br><span class="line">    int rc = munmap(addr, LENGTH);</span><br><span class="line">    assert(rc != -1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存映射通过文件，因此可以通过任意两个进程之间通信；匿名映射没有文件实体，因此只能有亲缘关系的进程共享使用。</p><h3 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h3><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时称之为软件中断。</p><p>产生信号的几种方式：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号，比如 <code>Ctrl + C</code> 会给进程发送一个中断进程。</li><li>硬件发生异常，硬件检测到一个错误条件并通知内核，随即再由内核发送相关信号给相关进程。</li><li>运行 <code>kill</code> 命令或函数</li><li>系统状态发生变化</li></ul><p>使用信号的两个主要目的：</p><ul><li>让进程知道已经发生了一个特定的事情</li><li>强迫进程执行它自己代码中的信号处理程序</li></ul><p>查看系统定义的信号列表：<code>kill -l</code></p><table><thead><tr><th>编号</th><th>信号名称</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>2</td><td>SIGINT</td><td>用户按下 <code>Ctrl + C</code></td><td>终止进程</td></tr><tr><td>3</td><td>SIGQUIT</td><td>用户按下 <code>Ctrl + \</code></td><td>终止进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程</td><td>可以杀死任何进程（僵尸进程除外）</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问（段错误）</td><td>终止进程并产生 core 文件</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe，向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行</td><td>继续&#x2F;忽略</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td>为终止进程</td></tr></tbody></table><p>查看进程的详细信息：<code>man 7 signal</code></p><p>信号的 5 中默认处理动作：</p><ul><li>Term 终止进程</li><li>Tgn 当前进程忽略掉这个信号</li><li>Core 终止进程，并生成一个 Core 文件</li><li>Stop 暂停当前进程</li><li>Cont 继续执行当前被暂停的进程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *s;</span><br><span class="line">    strcpy(s, &quot;Hello World\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作如下，我使用的是 <code>wsl + ubuntu22.04</code> ，因此，操作和老师有点不一样，直接运行 gdb 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">➜  nowcoker ulimit -c unlimited</span><br><span class="line">➜  nowcoker gcc a.c -o a -g</span><br><span class="line">➜  nowcoker ./a</span><br><span class="line">[1]    2361 segmentation fault (core dumped)  ./a</span><br><span class="line">➜  nowcoker gdb a</span><br><span class="line">...</span><br><span class="line">(gdb) run</span><br><span class="line">...</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x000055555555513f in main () at a.c:6</span><br><span class="line">6           strcpy(s, &quot;Hello World\n&quot;);</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>生成的 core 文件的位置可以通过 <code>cat /proc/sys/kernel/core_pattern</code> 查看。</p><h3 id="kill、raise、abort-函数"><a href="#kill、raise、abort-函数" class="headerlink" title="kill、raise、abort 函数"></a>kill、raise、abort 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">/* - 功能：给某个进程或进程组 pid，发送某个信号 sig</span><br><span class="line">- sig 需要发送的信号的编号或宏值，0 表示不发送信号 */</span><br><span class="line">int raise(int sig);</span><br><span class="line">// 给当前进程发送信号</span><br><span class="line">void abort(void);</span><br><span class="line">// 发送 SIGABRT 信号给当前进程，杀死当前进程</span><br></pre></td></tr></table></figure><h3 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">unsigned int alarm(unsigned in seconds);</span><br><span class="line">// 设置定时器，函数开始倒计时，倒计时为 0 时，函数会给当前进程发送一个信号：SIGALARM</span><br><span class="line">// SIGALARM：默认终止当前的进程，每个进程有且只有一个定时器，后续的 alarm 会覆盖前面的</span><br><span class="line">// 非阻塞函数</span><br></pre></td></tr></table></figure><p>统计一秒钟计算机能数多少个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">volatile int i = 0;</span><br><span class="line"></span><br><span class="line">void myalarm(int num)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, i);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line">    alarm(1);</span><br><span class="line">    while (1) &#123; i++; &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接执行 <code>I/O</code> 操作比较耗时，我们可以将输出重定向到文件中，<code>./a.out &gt;&gt; a.txt</code> ，这是这样还是会有 <code>I/O</code> 操作，而且调用 <code>printf</code> 函数也会耗时。因此，这样利用信号处理函数得到信号时输出是最好的。</p><h3 id="setitimer-定时器函数"><a href="#setitimer-定时器函数" class="headerlink" title="setitimer 定时器函数"></a>setitimer 定时器函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int setitimer(int which, const struct itimerval *new_val, struct itimerval * old_val);</span><br><span class="line">/* - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">            - which : 定时器以什么时间计时</span><br><span class="line">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="line">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line"></span><br><span class="line">            - new_value: 设置定时器的属性</span><br><span class="line"></span><br><span class="line">                struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                struct timeval &#123;        // 时间的结构体</span><br><span class="line">                    time_t      tv_sec;     //  秒数     </span><br><span class="line">                    suseconds_t tv_usec;    //  微秒    </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            过10秒后，每个2秒定时一次</span><br><span class="line"></span><br><span class="line">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">        </span><br><span class="line">        - 返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1 并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>一个例子，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">void myalarm(int num)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">    printf(&quot;第 %d 次计时。\n&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line">    struct itimerval new_value;</span><br><span class="line">    // 设置间隔的时间</span><br><span class="line">    new_value.it_interval.tv_sec = 2;</span><br><span class="line">    new_value.it_interval.tv_usec = 0;</span><br><span class="line">    // 设置延迟的时间,3秒之后开始第一次定时</span><br><span class="line">    new_value.it_value.tv_sec = 3;</span><br><span class="line">    new_value.it_value.tv_usec = 0;</span><br><span class="line">    int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞的</span><br><span class="line">    printf(&quot;定时器开始了...\n&quot;);</span><br><span class="line">    assert(ret != -1);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会在 3 秒后发送信号，进程接受信号后没有处理，那么就会直接中断。因为是非阻塞的，因此我们可以输入一个字符，让进程直接停止。</p><h3 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">/* 设置某个信号的捕捉行为</span><br><span class="line">signum：要捕捉的信号</span><br><span class="line">handler 要捕捉到信号要如何处理</span><br><span class="line">- SIG_IGN：忽略信号哦</span><br><span class="line">- SIG_DFL：使用信号默认行为</span><br><span class="line">- 回调函数</span><br><span class="line">- 返回值：</span><br><span class="line">成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">失败，返回SIG_ERR，设置错误号 </span><br><span class="line">SIGKILL SIGSTOP不能被捕捉，不能被忽略*/</span><br></pre></td></tr></table></figure><p>使用 alarm 和 setitimer 定时如上。</p><h3 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h3><p>多个信号组成的一个集合称为信号集，其系统数据类型为 sigset_t 。</p><p>在 PCB 中有两个非常重要的信号集，一个称为“阻塞信号集”，另一个是“未决信号集”。信号产生但是没有被处理 （未决），在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）。这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较，在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int sigemptyset(sigset_t *set);</span><br><span class="line">// 清空信号集中的数据</span><br><span class="line">int sigfillset(sigset_t *set);</span><br><span class="line">// 将信号集中的所有的标志位置为 0</span><br><span class="line">int sigaddset(sigset_t *set, int signum);</span><br><span class="line">// 设置信号集中的某一信号对应的标志位为 1 表示阻塞</span><br><span class="line">in sigdelset(sigset_t *set, in signum);</span><br><span class="line">// 设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">// 判断某个信号是否阻塞</span><br></pre></td></tr></table></figure><h3 id="sigprocmask-函数使用"><a href="#sigprocmask-函数使用" class="headerlink" title="sigprocmask 函数使用"></a>sigprocmask 函数使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">/* how 如何对内核阻塞信号进行操作</span><br><span class="line">SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="line">假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="line">   SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="line">        mask &amp;= ~set</span><br><span class="line">    SIG_SETMASK:覆盖内核中原来的值 */</span><br><span class="line">int sigpending(sigset_t *set);</span><br><span class="line">// 获取内存中的未决信号集 </span><br></pre></td></tr></table></figure><p>一个小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 自定义阻塞 2 和 3 的进程阻塞集</span><br><span class="line">    sigset_t set;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGINT);</span><br><span class="line">    sigaddset(&amp;set, SIGQUIT);</span><br><span class="line">    // 修改阻塞进程集为 set</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        sigset_t pset;</span><br><span class="line">        sigemptyset(&amp;pset);</span><br><span class="line">        sigpending(&amp;pset);</span><br><span class="line">        for (int i = 1; i &lt; 32; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d&quot;, sigismember(&amp;pset, i));</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        if (count == 10)</span><br><span class="line">        &#123;</span><br><span class="line">            // 解除阻塞，如果不解除阻塞，那么 Ctrl + C 终止进程，只能手动 kill</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction 信号捕捉函数"></a>sigaction 信号捕捉函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br><span class="line">/*- 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">            - act ：捕捉到信号之后的处理动作</span><br><span class="line">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="line">        - 返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line">struct sigaction &#123;</span><br><span class="line">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="line">        void     (*sa_handler)(int);</span><br><span class="line">        // 不常用</span><br><span class="line">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="line">        sigset_t   sa_mask;</span><br><span class="line">        // 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="line">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="line">        int        sa_flags;</span><br><span class="line">        // 被废弃掉了</span><br><span class="line">        void     (*sa_restorer)(void);</span><br><span class="line">    &#125;;*/</span><br></pre></td></tr></table></figure><p>小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void myalarm(int num)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;捕捉到了信号的编号是：%d\n&quot;, num);</span><br><span class="line">    printf(&quot;xxxxxxx\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask); // 清空临时阻塞信号集</span><br><span class="line">    // 注册信号捕捉</span><br><span class="line">    sigaction(SIGALRM, &amp;act, NULL);</span><br><span class="line">    struct itimerval new_value;</span><br><span class="line">    // 设置间隔的时间</span><br><span class="line">    new_value.it_interval.tv_sec = 2;</span><br><span class="line">    new_value.it_interval.tv_usec = 0;</span><br><span class="line">    // 设置延迟的时间,3秒之后开始第一次定时</span><br><span class="line">    new_value.it_value.tv_sec = 3;</span><br><span class="line">    new_value.it_value.tv_usec = 0;</span><br><span class="line">    int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞的</span><br><span class="line">    printf(&quot;定时器开始了...\n&quot;);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;setitimer&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    while (1)</span><br><span class="line">        ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能用 getchar 阻塞的原因在于：</p><blockquote><p>Interruption of system calls and library functions by signal handlers</p><p>If a signal handler is invoked while a system call or library function call is blocked, then either:<br>* the call is automatically restarted after the signal handler returns; or<br>* the call fails with the error EINTR.</p><p>我们的 sigaction 中的 sa_flags 未设置 SA_RESTART 所以会是第二种行为，系统调用被中断，下面有讲到 read 从终端读取数据是会被 signal handler 中断，getchar 底层应该调用的是 read。</p></blockquote><h3 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h3><p>产生条件：</p><ul><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处于停止态，接受到 SIGCONT 后唤醒时</li></ul><p>因为上面三种情况都会给父进程发送 SIGCHLD 信号，因此，可以使用 SIGCHLD 信号解决僵尸进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">void myFun(int num)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;捕捉到的信号 ：%d\n&quot;, num);</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        int ret = waitpid(-1, NULL, WNOHANG); // 非阻塞的</span><br><span class="line">        if (ret &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;child die , pid = %d\n&quot;, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // 说明还有子进程活着</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ret == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            // 没有子进程</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span><br><span class="line">    sigset_t set;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line"></span><br><span class="line">    // 创建一些子进程</span><br><span class="line">    pid_t pid;</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 父进程</span><br><span class="line"></span><br><span class="line">        // 捕捉子进程死亡时发送的SIGCHLD信号</span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_flags = 0;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, NULL);</span><br><span class="line"></span><br><span class="line">        // 注册完信号捕捉以后，解除阻塞</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;parent process pid : %d\n&quot;, getpid());</span><br><span class="line">            sleep(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 子进程</span><br><span class="line">        printf(&quot;child process pid : %d\n&quot;, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存允许两个或多个进程共享物理内存的同一块区域，通常称为段。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。</p><p>这种机制的速度更快，因为没有复制数据等过程。</p><ul><li>调用 shmget() 创建一个新共享内存段或获取一个既有共享内存段的标识符。</li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。</li><li>调用 shmctl() 来删除共享内存段，只需执行一次。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"> int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为0</span><br><span class="line">    - 参数：</span><br><span class="line">        - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用16进制表示，非0值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | 0664</span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：-1 并设置错误号</span><br><span class="line">            成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： 0</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(void *) -1</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 0， 失败 -1</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，NULL</span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">    - 功能：根据指定的路径名，和int值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节</span><br><span class="line">                   范围 ： 0-255  一般指定一个字符 &#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>问题1：操作系统如何知道一块共享内存被多少个进程关联？</p><ul><li>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</li><li>shm_nattach 记录了关联的进程个数</li></ul><p>问题2：可不可以对共享内存进行多次删除 shmctl</p><ul><li>可以的</li><li>因为shmctl 标记删除共享内存，不是直接删除</li><li>什么时候真正删除呢?<ul><li>当和共享内存关联的进程数为0的时候，就真正被删除</li><li>当共享内存的key为0的时候，表示共享内存被标记删除了</li><li>如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</li></ul></li></ul><p>共享内存和内存映射的区别</p><ol><li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li><li>共享内存效果更高</li><li>内存</li><li>所有的进程操作的是同一块共享内存。</li><li>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li><li>数据安全<ol><li>进程突然退出</li><li>共享内存还存在</li><li>内存映射区消失</li><li>运行进程的电脑死机，宕机了</li><li>数据存在在共享内存中，没有了</li><li>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li></ol></li><li>生命周期<ol><li>内存映射区：进程退出，内存映射区销毁</li><li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</li><li>如果一个进程退出，会自动和共享内存进行取消关联。</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// a.c</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int key = ftok(&quot;.&quot;, 888);</span><br><span class="line">    int shmid = shmget(key, 4096, IPC_CREAT | 0664);</span><br><span class="line">    printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line">    void *addr = shmat(shmid, NULL, 0);</span><br><span class="line">    memcpy(addr, &quot;Hello World&quot;, 12); // 写</span><br><span class="line">    printf(&quot;Press any key to continue...\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(addr);</span><br><span class="line">    shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// b.c</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int key = ftok(&quot;.&quot;, 888);</span><br><span class="line">    int shmid = shmget(key, 0, IPC_CREAT);</span><br><span class="line">    printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line">    void *addr = shmat(shmid, NULL, 0);</span><br><span class="line">    printf(&quot;%s\n&quot;, (char *)addr); // 读</span><br><span class="line">    printf(&quot;Press any key to continue...\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(addr);</span><br><span class="line">    shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://image.ceyewan.top/typora/image-20220626144136503.png"><img src="https://image.ceyewan.top/typora/image-20220626144136503.png" alt="image-20220626144136503"></a></p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>终端、进程组、会话等关系。</p><ul><li>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务器。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待某些发生的事件。一般采用 d 结尾的名字。</li><li>生命周期长，在后台运行并且不拥有控制终端。</li></ul><p>守护进程的创建步骤：</p><ul><li>执行一个 fork()，之后父进程退出，子进程继续执行</li><li>子进程调用 setsid() 开启一个新会话</li><li>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限</li><li>修改进程的当前工作目录，通常会改为更目录。</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</li><li>在关闭了文件描述符 0 1 2 之后，守护进程通常会打开 <code>/dev/null</code> 并使用 dup2() 使所有这些描述符指向这个设备。</li><li>核心业务逻辑。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">// 计时信号应答函数</span><br><span class="line">void work(int num)</span><br><span class="line">&#123;</span><br><span class="line">    time_t tm = time(NULL);</span><br><span class="line">    struct tm *loc = localtime(&amp;tm);</span><br><span class="line">    char *str = asctime(loc);</span><br><span class="line">    int fd = open(&quot;time.txt&quot;, O_RDWR | O_CREAT | O_APPEND, 0664);</span><br><span class="line">    write(fd, str, strlen(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    // 子进程创建新会话组</span><br><span class="line">    setsid();</span><br><span class="line">    // 设置掩码</span><br><span class="line">    umask(022);</span><br><span class="line">    // 修改进程的当前工作目录</span><br><span class="line">    chdir(&quot;/home/ceyewan/CodeField/CODE_CPP/nowcoker&quot;);</span><br><span class="line">    // 重定向文件描述符</span><br><span class="line">    int fd = open(&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    // 计时器，每隔两秒计时一下</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, NULL);</span><br><span class="line">    struct itimerval val;</span><br><span class="line">    val.it_interval.tv_sec = 2;</span><br><span class="line">    val.it_interval.tv_usec = 0;</span><br><span class="line">    val.it_value.tv_sec = 2;</span><br><span class="line">    val.it_value.tv_usec = 0;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, NULL);</span><br><span class="line">    // 避免进程结束</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台守护程序，每隔两秒发送信号，接受到信号后向文件中写入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;内存映射&quot;&gt;&lt;a href=&quot;#内存映射&quot; class=&quot;headerlink&quot; title=&quot;内存映射&quot;&gt;&lt;/a&gt;内存映射&lt;/h3&gt;&lt;p&gt;内存映射是将磁盘文件中的数据映射到内存，用户通过修改内存就能修改磁盘文件。&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多进程开发（一）</title>
    <link href="http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/12/16/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-12-16T11:07:46.000Z</published>
    <updated>2022-12-16T11:16:31.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h3><ul><li>进程是正在运行的程序的实例，是基本的分配单元也是基本的执行单元。</li><li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。</li><li>单道程序：计算机内存中只允许一个程序运行</li><li>多道程序：计算机内存中同时放几道相互独立的程序，使它们在调度下，相互穿插运行。</li><li>时间片：操作系统分配给每个正在运行的进程微观上的一段时间。</li><li>并发：指在同一时刻，有多条指令在多个处理器上同时执行。</li><li>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li><li>内核为每个进程分配一个 <code>PCB</code> 进程控制块，维护进程相关的信息，<code>Linux</code> 内核的进程控制块是 <code>task_struct</code> 结构体（<code>/usr/src/linux-headers-xxx/include/linux/sched.h</code> 中）</li></ul><h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><ul><li><p>[新建态]、运行态、就绪态、阻塞态、[终止态]</p></li><li><p>查看进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux / ajx</span><br></pre></td></tr></table></figure><ul><li>a：显示终端上的所有进程，包括其他用户的进程</li><li>u：显示进程的详细信息</li><li>x：显示没有控制终端的进程</li><li>j：列出与作业控制相关的信息</li></ul></li><li><p>STAT 参数的意义：</p><ul><li>D：不可中断</li><li>R：正在运行或在队列中的进程</li><li>S：处于休眠状态</li><li>T：停止或被追踪</li><li>Z：僵尸进程</li><li>W：进入内存交换</li><li>X：死掉的进程</li><li>&lt;：高优先级</li><li>N：低优先级</li><li>S：包含子进程</li><li>+：位于前台的进程组</li></ul></li><li><p>实时显示进程动态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-d 5]</span><br></pre></td></tr></table></figure><ul><li>-d 来指定信息更新的时间间隔</li><li>M 根据内存使用量排序</li><li>P 根据 CPU 占有率排序</li><li>T 根据进程运行时间排序</li><li>U 根据用户名排序</li><li>K 输入指定的 PID 杀死进程</li></ul></li><li><p>杀死进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><ul><li><code>kill -l</code> 列出所有信号</li><li><code>kill –SIGKILL pid</code></li><li><code>kill -9 pid</code></li><li><code>killall name xxx</code> 根据进程名杀死进程</li></ul></li><li><p>进程号和相关函数</p><ul><li>每个进程都对应唯一一个进程号，类型为 <code>pid</code></li><li>任何进程（除 <code>init</code> 进程）都由一个进程创建，该进程称为被创建进程的父进程 <code>PPID</code></li><li>进程组是一个或多个进程的集合，有个进程组号，为 <code>PGID</code> 。</li><li><code>pid_t getpid(void)</code> 和 <code>pid_t getppid(void)</code> 和 <code>pid_t getpgid(pid_t pid)</code></li></ul></li></ul><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pid_t fork(void);</span><br><span class="line">// 创建一个和父进程一模一样的子进程，子进程从这行开始执行</span><br><span class="line">// 子进程返回 0，父进程返回子进程的 pid，失败返回 -1</span><br></pre></td></tr></table></figure><p>完全的复制操作，可以认为只有 <code>pid</code> 不同， 相互之间几乎没有联系。（准确来说，<code>Linux</code> 的 <code>fork()</code> 使用的是写时拷贝，<code>fork</code> 时并不复制整个地址空间，而是共享，只有当需要写入时才会复制。这样效率高）</p><h3 id="父子进程关系和-GDB-调试"><a href="#父子进程关系和-GDB-调试" class="headerlink" title="父子进程关系和 GDB 调试"></a>父子进程关系和 GDB 调试</h3><p><strong>父子进程关系</strong></p><ul><li><code>fork</code> 函数的返回值不同</li><li><code>PCB</code> 中的进程号和信号集等不同</li><li>数据读时共享，写时拷贝</li></ul><p><strong>GDB 调试</strong></p><ul><li>设置调试子进程，<code>set follow-fork-mode child</code> ，默认是父进程</li><li>设置调试模式，<code>set detch-on-fork on/off</code>，默认为 <code>on</code> ，表示调试当前进程时其他进程继续运行；否则，挂起。</li><li>查看调试的进程，<code>info inferiors</code></li><li>切换当前调试的进程：<code>inferior id</code></li><li>使进程脱离 GDB 的调试：<code>detach inferiors id</code></li></ul><h3 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h3><p>根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，也就是在调用进程内部执行一个可执行文件。</p><p>执行成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈都被新的内容取代，只保留进程 ID 等表面信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );</span><br><span class="line">/* </span><br><span class="line">- path 需要执行的文件的路径或者名称，相对路径or绝对路径</span><br><span class="line">- arg 是执行可执行文件的参数列表</span><br><span class="line">- 第一个参数没有用</span><br><span class="line">- 最后一个参数为 NULL</span><br><span class="line">execl(&quot;a.out&quot;, &quot;a.out&quot;,&quot;10&quot;, NULL);</span><br><span class="line">execl(&quot;/bin/ps&quot;, &quot;ps&quot;, NULL);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int execv(const char *pathname, char *const argv[]); </span><br><span class="line"></span><br><span class="line">int execle(const char *pathname, const char *arg0, .../* (char *)0, char *const envp[] */ );</span><br><span class="line"></span><br><span class="line">int execve(const char *pathname, char *const argv[], char*const envp[]);</span><br><span class="line"></span><br><span class="line">int execlp(const char *filename, const char *arg0, ... /*(char *)0 */ );</span><br><span class="line">/*</span><br><span class="line">- file 需要执行的可执行文件名</span><br><span class="line">- execl(&quot;ps&quot;, &quot;ps&quot;, NULL);</span><br><span class="line">- 这个函数可以从环境路径自行查找</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int execvp(const char *filename, char *const argv[]);</span><br><span class="line"> </span><br><span class="line">int fexecve(int fd, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure><ul><li><code>l(list)</code> 参数地址列表，以空指针结尾</li><li><code>v(vector)</code> 存有各参数地址的指针数组的地址</li><li><code>p(path)</code> 按 PATH 环境变量指定的目录搜索可执行文件</li><li><code>e(environment)</code> 存有环境变量字符串地址的指针数组的地址，自行指定环境路径</li></ul><h3 id="进程退出、孤儿进程、僵尸进程"><a href="#进程退出、孤儿进程、僵尸进程" class="headerlink" title="进程退出、孤儿进程、僵尸进程"></a>进程退出、孤儿进程、僵尸进程</h3><p>父进程有回收子进程资源的要求。</p><h4 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">void exit(int status); // 标准 C 库</span><br><span class="line">void _exit(int status); // Linux 系统，没有处理缓冲区等操作，直接退出</span><br><span class="line">// status 是进程退出时的状态信息，父进程回收子进程资源时可以获取</span><br></pre></td></tr></table></figure><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>父进程运行结束，子进程还在运行。那么子进程就是一个孤儿进程，内核会把孤儿进程的父进程设置为 <code>init</code> 。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>每个进程结束后，都会释放用户区数据，内核区的 PCB 需要父进程释放。</p><p>进程终止，父进程尚未回收，子进程残留 PCB 存放于内核中，变成僵尸进程。</p><p>僵尸进程不能被 <code>kill -9</code> 杀死。</p><p>杀死父进程，让僵尸进程被 <code>init</code> 接管，<code>init</code> 会定时释放子进程的内核区。</p><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h3><p>父进程回收子进程的资源，通过调用 wait 或 waitpid 得到子进程退出状态同时彻底清除这个进程。</p><p>wait() 函数会阻塞，waitpid 可以设置不阻塞，同时还可以指定等待哪个子进程结束。</p><p>一个 wait 或 waitpid 一次只能清理一个子进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">// 参数为进程的退出状态，不接受那就用 NULL</span><br><span class="line">// 成功返回回收的子进程的 id，失败返回 -1</span><br></pre></td></tr></table></figure><p>调用 wait 函数的进程将被挂起，直到它的一个子进程退出或者没有任何子进程了（返回 -1）。</p><h3 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">// 回收指定子进程</span><br><span class="line">wait(&amp;status) = waitpid(-1, &amp;status, 0);</span><br><span class="line">// pid &lt; -1, 回收某个进程组的组 id 的绝对值，回收指定进程组的子进程</span><br><span class="line">// pid = -1, 回收所有的子进程中的一个</span><br><span class="line">// pid &gt; 0, 回收指定的 pid 进程</span><br><span class="line">// pid = 0, 回收当前进程组的任意一个进程</span><br><span class="line">// options：0表示阻塞，WNOHANG 表示非阻塞</span><br><span class="line">// 返回值大于 0 为成功，-1 为失败，0表示非阻塞，还有子进程</span><br></pre></td></tr></table></figure><p>父进程可以不阻塞的回收子进程，这样的话，父进程既可以做自己的事，又能适时回收子进程。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程是一个独立的资源分配单元，不同进程资源独立，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同进程需要进行信息交互和状态的传递，因此需要进程间通信（IPC）。</p><p><a href="https://image.ceyewan.top/typora/image-20220623230811181.png"><img src="https://image.ceyewan.top/typora/image-20220623230811181.png" alt="image-20220623230811181"></a></p><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>管道也叫无名（匿名）管道，是 UNIX 系统 IPC 的最古老的形式。</p><p>统计一个目录中文件的数目命令 <code>ls | wc -l</code> ，两个进程，<code>ls </code>将数据写入管道，<code>wc</code> 从管道中读取数据（单向字节流管道）。</p><ul><li>管道其实是一个在内核内存中维护的缓冲器。</li><li>管道拥有文件特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体但不存储数据。</li><li>一个管道是一个顺序字节流，类似于双指针环形队列。</li><li>匿名进程只用用于具有关系的进程之间的通信。</li></ul><h3 id="父子进程通过匿名管道通信"><a href="#父子进程通过匿名管道通信" class="headerlink" title="父子进程通过匿名管道通信"></a>父子进程通过匿名管道通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// 创建匿名管道，用于进程间通信</span><br><span class="line">// pipefd[0]：读端，pipefd[1]：写端</span><br><span class="line">// 成功返回 0 ，失败返回 -1</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">// 查看管道缓冲大小</span><br><span class="line">ulimit -a</span><br><span class="line">// 查看管道缓冲大小的函数</span><br><span class="line">long fpathconf(pipefd[0], int name);</span><br></pre></td></tr></table></figure><h3 id="匿名管道通信案例"><a href="#匿名管道通信案例" class="headerlink" title="匿名管道通信案例"></a>匿名管道通信案例</h3><p>实现 <code>ps aux | grep root</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int p[2];</span><br><span class="line">    int rc = pipe(p);</span><br><span class="line">    assert(rc != -1);</span><br><span class="line">    int pid = fork();</span><br><span class="line">    assert(pid != -1);</span><br><span class="line">    if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = close(p[0]);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        rc = dup2(p[1], STDOUT_FILENO);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        rc = execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rc = close(p[1]);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        rc = dup2(p[0], STDIN_FILENO);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        rc = execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;root&quot;, NULL);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端对比，基本一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">➜  nowcoker gcc a.c </span><br><span class="line">➜  nowcoker ./a.out </span><br><span class="line">root         1  0.0  0.0   1744  1076 ?        Sl   00:03   0:00 /init</span><br><span class="line">root        10  0.0  0.0   1752    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        11  0.0  0.0   1752    72 ?        S    00:03   0:00 /init</span><br><span class="line">root        45  0.0  0.0   1764    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        46  0.0  0.0   1764    80 ?        S    00:03   0:00 /init</span><br><span class="line">root        63  0.0  0.0   1764    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        64  0.1  0.0   1764    80 ?        S    00:03   0:01 /init</span><br><span class="line">ceyewan    716  0.0  0.0   9576  2408 pts/3    S+   00:14   0:00 grep root</span><br><span class="line">➜  nowcoker ps aux | grep root # 这里的 root 显示为红色，因为最后那一段</span><br><span class="line">root         1  0.0  0.0   1744  1076 ?        Sl   00:03   0:00 /init</span><br><span class="line">root        10  0.0  0.0   1752    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        11  0.0  0.0   1752    72 ?        S    00:03   0:00 /init</span><br><span class="line">root        45  0.0  0.0   1764    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        46  0.0  0.0   1764    80 ?        S    00:03   0:00 /init</span><br><span class="line">root        63  0.0  0.0   1764    64 ?        Ss   00:03   0:00 /init</span><br><span class="line">root        64  0.1  0.0   1764    80 ?        S    00:03   0:01 /init</span><br><span class="line">ceyewan    756  0.0  0.0   9708  2280 pts/3    S+   00:16   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox root</span><br></pre></td></tr></table></figure><h3 id="管道的读写特点和管道设置为非阻塞"><a href="#管道的读写特点和管道设置为非阻塞" class="headerlink" title="管道的读写特点和管道设置为非阻塞"></a>管道的读写特点和管道设置为非阻塞</h3><ul><li>如果所有指向写端的文件描述符关闭（没关闭）了，那么 read 会（返回 0）（阻塞）。</li><li>如果所有指向读端的文件描述符关闭（没关闭）了，那么 write 会（收到 SIGPIPE 信号） （阻塞）。</li><li>设置管道非阻塞</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// 得到原 flags，添加非阻塞，然后写入</span><br><span class="line">int flags = fcntl(fd[0], F_GETFL);</span><br><span class="line">flags |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[0], F_SETFL, flags);</span><br></pre></td></tr></table></figure><h3 id="有名管道介绍及使用"><a href="#有名管道介绍及使用" class="headerlink" title="有名管道介绍及使用"></a>有名管道介绍及使用</h3><p>有名管道，FIFO，也叫命名管道。</p><ol><li>FIFO 在文件系统作为一个特殊文件存在，但是内容放在内存中</li><li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中</li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">// 通过命令创建有名管道</span><br><span class="line">mkfifo xxx;</span><br><span class="line">// 通过函数创建有名管道</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">// mode 和 open 是一样的</span><br></pre></td></tr></table></figure><h3 id="有名管道实现简易聊天功能"><a href="#有名管道实现简易聊天功能" class="headerlink" title="有名管道实现简易聊天功能"></a>有名管道实现简易聊天功能</h3><blockquote><p>a.c</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int rc = access(&quot;fifo1&quot;, F_OK);</span><br><span class="line">    if (rc == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = mkfifo(&quot;fifo1&quot;, 0664);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    rc = access(&quot;fifo2&quot;, F_OK);</span><br><span class="line">    if (rc == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = mkfifo(&quot;fifo2&quot;, 0664);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    int fdw = open(&quot;fifo1&quot;, O_WRONLY);</span><br><span class="line">    assert(fdw != -1);</span><br><span class="line">    int fdr = open(&quot;fifo2&quot;, O_RDONLY);</span><br><span class="line">    assert(fdr != -1);</span><br><span class="line">    int pid = fork();</span><br><span class="line">    assert(pid &gt;= 0);</span><br><span class="line">    if (pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = close(fdr);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        char s[3];</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sprintf(s, &quot;%d\n&quot;, i);</span><br><span class="line">            rc = write(fdw, s, strlen(s));</span><br><span class="line">            assert(rc != -1);</span><br><span class="line">            printf(&quot;A write %s&quot;, s);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        rc = close(fdw);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rc = close(fdw);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        char buf[3];</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            rc = read(fdr, buf, 3);</span><br><span class="line">            assert(rc != -1);</span><br><span class="line">            if (rc == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;A read all right.\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;A read %s&quot;, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        rc = close(fdr);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>b.c</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // b 如果也创建管道的话可能会有并发问题</span><br><span class="line">    int fdr = open(&quot;fifo1&quot;, O_RDONLY);</span><br><span class="line">    assert(fdr != -1);</span><br><span class="line">    int fdw = open(&quot;fifo2&quot;, O_WRONLY);</span><br><span class="line">    assert(fdw != -1);</span><br><span class="line">    int pid = fork();</span><br><span class="line">    assert(pid &gt;= 0);</span><br><span class="line">    if (pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int rc = close(fdr);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        char s[3];</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sprintf(s, &quot;%d\n&quot;, i);</span><br><span class="line">            rc = write(fdw, s, strlen(s));</span><br><span class="line">            assert(rc != -1);</span><br><span class="line">            printf(&quot;B write %s&quot;, s);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        rc = close(fdw);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int rc = close(fdw);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">        char buf[3];</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            rc = read(fdr, buf, 3);</span><br><span class="line">            assert(rc != -1);</span><br><span class="line">            if (rc == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;B read all right.\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;B read %s&quot;, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        rc = close(fdr);</span><br><span class="line">        assert(rc != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">➜  nowcoker gcc a.c -o a &amp; gcc b.c -o b</span><br><span class="line">[1] 2731</span><br><span class="line">[1]  + 2731 done       gcc a.c -o a</span><br><span class="line">➜  nowcoker ./a &amp; ./b                  </span><br><span class="line">[1] 2743</span><br><span class="line">A write 0</span><br><span class="line">B write 0</span><br><span class="line">A read 0</span><br><span class="line">B read 0</span><br><span class="line">B read 1</span><br><span class="line">A write 1</span><br><span class="line">B write 1</span><br><span class="line">A read 1</span><br><span class="line">B read 2</span><br><span class="line">A read 2</span><br><span class="line">A write 2</span><br><span class="line">B write 2</span><br><span class="line">A read all right.</span><br><span class="line">B read all right.</span><br><span class="line">[1]  + 2743 done       ./a</span><br><span class="line">➜  nowcoker rm fifo1 fifo2 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;进程概述&quot;&gt;&lt;a href=&quot;#进程概述&quot; class=&quot;headerlink&quot; title=&quot;进程概述&quot;&gt;&lt;/a&gt;进程概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程是正在运行的程序的实例，是基本的分配单元也是基本的执行单元。&lt;/li&gt;
&lt;li&gt;可以用一个程序来创建多个进程</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>1.Linux 系统编程入门</title>
    <link href="http://example.com/2022/12/06/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/12/06/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-12-05T16:31:20.000Z</published>
    <updated>2022-12-16T09:34:10.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统编程入门"><a href="#Linux-系统编程入门" class="headerlink" title="Linux 系统编程入门"></a>Linux 系统编程入门</h1><h2 id="Linux开发环境搭建"><a href="#Linux开发环境搭建" class="headerlink" title="Linux开发环境搭建"></a>Linux开发环境搭建</h2><ol><li>安装虚拟机</li><li>安装 <code>vscode + remote ssh</code> 插件</li><li><code>ssh</code> 远程连接虚拟机</li></ol><h2 id="GCC和G"><a href="#GCC和G" class="headerlink" title="GCC和G++"></a>GCC和G++</h2><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/g++ -v/--version</span><br></pre></td></tr></table></figure><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i # 预处理</span><br><span class="line">gcc -S a.i -o a.s # 编译</span><br><span class="line">gcc -c a.s -o a.o # 汇编</span><br><span class="line">gcca.o b.o -o a.out # 链接</span><br><span class="line">gcc a.c -l pthread -o a # 手动添加链接库</span><br></pre></td></tr></table></figure><h3 id="G"><a href="#G" class="headerlink" title="G++"></a>G++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp -o test.i # 预处理</span><br><span class="line">g++ -S test.i -o xxx.s # 编译</span><br><span class="line">g++ -c test.s -o xxx.o # 汇编</span><br><span class="line">g++ test.o -o test.exe # 链接</span><br></pre></td></tr></table></figure><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以认为 g++ = gcc -lstdc++ 链接了 C++ 库。</span><br></pre></td></tr></table></figure><h2 id="静态库的制作与使用"><a href="#静态库的制作与使用" class="headerlink" title="静态库的制作与使用"></a>静态库的制作与使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">命名：</span><br><span class="line">Linux : libxxx.a</span><br><span class="line">lib : 前缀（固定）</span><br><span class="line">xxx : 库的名字，自己起</span><br><span class="line">.a : 后缀（固定）</span><br><span class="line">Windows : libxxx.lib</span><br><span class="line">静态库的制作：</span><br><span class="line">gcc 获得 .o 文件</span><br><span class="line">将 .o 文件打包，使用 ar 工具（archive）</span><br><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br><span class="line">r – 将文件插入备存文件中</span><br><span class="line">c – 建立备存文</span><br><span class="line">s – 索引</span><br></pre></td></tr></table></figure><h2 id="动态库的制作与使用"><a href="#动态库的制作与使用" class="headerlink" title="动态库的制作与使用"></a>动态库的制作与使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">命名规则：</span><br><span class="line">Linux : libxxx.so</span><br><span class="line">lib : 前缀（固定）</span><br><span class="line">xxx : 库的名字，自己起</span><br><span class="line">.so : 后缀（固定）</span><br><span class="line">在Linux下是一个可执行文件</span><br><span class="line">Windows : libxxx.dll</span><br><span class="line">动态库的制作：</span><br><span class="line">gcc 得到 .o 文件，得到和位置无关的代码</span><br><span class="line">gcc -c –fpic/-fPIC a.c b.c</span><br><span class="line">gcc 得到动态库</span><br><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure><h2 id="静态库与动态库的对比"><a href="#静态库与动态库的对比" class="headerlink" title="静态库与动态库的对比"></a>静态库与动态库的对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 静态库：</span><br><span class="line">  - `GCC` 进行链接时，会把静态库中代码打包到可执行程序中</span><br><span class="line">  - 优点，使用简单</span><br><span class="line">  - 缺点，造成可执行文件体积庞大，重复加载等</span><br><span class="line">- 动态库：</span><br><span class="line">  - `GCC` 进行链接时，动态库的代码不会被打包到可执行程序中</span><br><span class="line">  - 缺点：使用复杂</span><br><span class="line">  - 优点：无需加载，速度快，共享使用（加载到内存后可以供多个进程使用）</span><br></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="什么是-Makefile"><a href="#什么是-Makefile" class="headerlink" title="什么是 Makefile"></a>什么是 Makefile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">◼ 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令。</span><br><span class="line">◼ Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。 make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 make， Visual C++ 的 nmake， Linux 下 GNU 的 make。  </span><br></pre></td></tr></table></figure><h3 id="Makefile-文件命名和规则"><a href="#Makefile-文件命名和规则" class="headerlink" title="Makefile 文件命名和规则"></a>Makefile 文件命名和规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">◼ 文件命名</span><br><span class="line">makefile 或者 Makefile</span><br><span class="line">◼ Makefile 规则</span><br><span class="line">一个 Makefile 文件中可以有一个或者多个规则</span><br><span class="line">目标 ...: 依赖 ...</span><br><span class="line">命令（Shell 命令）</span><br><span class="line">...</span><br><span class="line">⚫ 目标：最终要生成的文件（伪目标除外）</span><br><span class="line">⚫ 依赖：生成目标所需要的文件或是目标</span><br><span class="line">⚫ 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</span><br><span class="line"> Makefile 中的其它规则一般都是为第一条规则服务的。</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">◼ 命令在执行之前，需要先检查规则中的依赖是否存在</span><br><span class="line"> 如果存在，执行命令</span><br><span class="line"> 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</span><br><span class="line">◼ 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</span><br><span class="line"> 如果依赖的时间比目标的时间晚，需要重新生成目标</span><br><span class="line"> 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">◼ 自定义变量</span><br><span class="line">变量名=变量值 var=hello</span><br><span class="line">◼ 预定义变量</span><br><span class="line">AR : 归档维护程序的名称，默认值为 ar</span><br><span class="line">CC : C 编译器的名称，默认值为 cc</span><br><span class="line">CXX : C++ 编译器的名称，默认值为 g++</span><br><span class="line">$@ : 目标的完整名称</span><br><span class="line">$&lt; : 第一个依赖文件的名称</span><br><span class="line">$^ : 所有的依赖文件</span><br><span class="line">◼ 获取变量的值</span><br><span class="line">$(变量名)</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add.o:add.c</span><br><span class="line">gcc -c add.c</span><br><span class="line">div.o:div.c</span><br><span class="line">gcc -c div.c</span><br><span class="line">sub.o:sub.c</span><br><span class="line">gcc -c sub.c</span><br><span class="line">mult.o:mult.c</span><br><span class="line">gcc -c mult.c</span><br><span class="line">main.o:main.c</span><br><span class="line">gcc -c main.c</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">◼ $(wildcard PATTERN...)</span><br><span class="line"> 功能：获取指定目录下指定类型的文件列表</span><br><span class="line"> 参数： PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</span><br><span class="line"> 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</span><br><span class="line"> 示例：</span><br><span class="line">$(wildcard *.c ./sub/*.c)</span><br><span class="line">返回值格式: a.c b.c c.c d.c e.c f.c06 / 函数</span><br><span class="line">◼ $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br><span class="line"> 功能：查找&lt;text&gt;中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式&lt;pattern&gt;，如果匹配的话，则&lt;replacement&gt;   替换。</span><br><span class="line"> &lt;pattern&gt;可以包括通配符`%`，表示任意长度的字串。如果&lt;replacement&gt;中也包含`%`，那么， &lt;replacement&gt;中的这个`%`将是   &lt;pattern&gt;中的那个%所代表的字串。 (可以用`\`来转义，以`\%`来表示真实含义的`%`字符)</span><br><span class="line">     返回：函数返回被替换过后的字符串</span><br><span class="line"> 示例：</span><br><span class="line">$(patsubst %.c, %.o, x.c bar.c)</span><br><span class="line">返回值格式: x.o bar.o</span><br></pre></td></tr></table></figure><p>参考资料</p><p>[<a href="https://seisman.github.io/how-to-write-makefile/index.html]">https://seisman.github.io/how-to-write-makefile/index.html]</a>: </p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>准备工作：</p><ul><li>关闭 <code>-O</code>优化，开启 <code>-Wall</code> 显示更多的 <code>warning</code></li><li>开启 <code>-g</code> 选项，在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 <code>gdb</code> 能找到源文件。</li></ul><p>GDB命令：</p><ul><li>启动 <code>gdb 可执行程序</code></li><li>退出 <code>quit/q</code></li><li>给程序设置参数，<code>set args 10 20</code> ，显示参数，<code>show args</code></li><li>使用帮助 <code>help [xxx]</code></li><li>查看当前文件代码 <code>list/l [xx](行号/函数名/文件名:行号/文件名:函数名)</code></li><li>设置显示的行数，<code>show[set] list/listsize</code></li><li>设置断点，<code>break/b [xx](行号/函数名/文件名:行号/文件名:函数名)</code></li><li>查看断点，<code>info/i b/break</code></li><li>删除断点，<code>d/del/delete 断点编号</code></li><li>设置断点无效&#x2F;生效，<code>dis/disable[ena/enable] 断点编号</code></li><li>设置条件断点，一般用于循环，<code>b 10 if i==5</code></li><li>运行 <code>gdb</code> 程序，<code>start(程序停在第一行)</code>，<code>run(遇到断点才停)</code></li><li>继续运行，下个断点停，<code>continue/c</code></li><li>向下执行一行代码，不进入函数体，<code>next/n</code></li><li>向下单步调试，进入函数体，<code>step/s</code>，跳出函数体，<code>finish</code></li><li>变量输出，<code>print/p 变量名</code>，<code>ptype 变量名</code></li><li>自动变量操作，自动打印指定变量的值，<code>display 变量名</code></li><li>修改变量的值，<code>set var 变量名=变量值</code>；跳出循环，<code>until</code></li></ul><h2 id="IO-函数"><a href="#IO-函数" class="headerlink" title="IO 函数"></a>IO 函数</h2><h3 id="open和close"><a href="#open和close" class="headerlink" title="open和close"></a>open和close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 打开一个已经存在的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment">            - flags：对文件的操作权限设置还有其他的设置</span></span><br><span class="line"><span class="comment">              O_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span></span><br><span class="line"><span class="comment">        返回值：返回一个新的文件描述符，如果调用失败，返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    void perror(const char *s);作用：打印errno对应的错误描述</span></span><br><span class="line"><span class="comment">        s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 创建一个新的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读写操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname：要创建的文件的路径</span></span><br><span class="line"><span class="comment">            - flags：对文件的操作权限和其他的设置</span></span><br><span class="line"><span class="comment">                - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的</span></span><br><span class="line"><span class="comment">                - 可选项：O_CREAT 文件不存在，创建新文件</span></span><br><span class="line"><span class="comment">            - mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775</span></span><br><span class="line"><span class="comment">            最终的权限是：mode &amp; ~umask</span></span><br><span class="line"><span class="comment">            0777   -&gt;   111111111</span></span><br><span class="line"><span class="comment">        &amp;   0775   -&gt;   111111101</span></span><br><span class="line"><span class="comment">        ----------------------------</span></span><br><span class="line"><span class="comment">                        111111101</span></span><br><span class="line"><span class="comment">        按位与：0和任何数都为0</span></span><br><span class="line"><span class="comment">        umask的作用就是抹去某些权限。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        flags参数是一个int类型的数据，占4个字节，32位。</span></span><br><span class="line"><span class="comment">        flags 32个位，每一位就是一个标志位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write和read"><a href="#write和read" class="headerlink" title="write和read"></a>write和read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    ssize_t read(int fd, void *buf, size_t count);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">            - buf：需要读取数据存放的地方，数组的地址（传出参数）</span></span><br><span class="line"><span class="comment">            - count：指定的数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：</span></span><br><span class="line"><span class="comment">                &gt;0: 返回实际的读取到的字节数</span></span><br><span class="line"><span class="comment">                =0：文件已经读取完了</span></span><br><span class="line"><span class="comment">            - 失败：-1 ，并且设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">            - buf：要往磁盘写入的数据，数据</span></span><br><span class="line"><span class="comment">            - count：要写的数据的实际的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：实际写入的字节数</span></span><br><span class="line"><span class="comment">            失败：返回-1，并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.通过open打开english.txt文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新的文件（拷贝文件）</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(destfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(destfd);</span><br><span class="line">    close(srcfd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fseek和lseek"><a href="#fseek和lseek" class="headerlink" title="fseek和lseek"></a>fseek和lseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="stat和lstat"><a href="#stat和lstat" class="headerlink" title="stat和lstat"></a>stat和lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件(具体文件)相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取软连接文件的相关信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h2><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chdir和getcwd"><a href="#chdir和getcwd" class="headerlink" title="chdir和getcwd"></a>chdir和getcwd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            返回的指向的一块内存，这个数据就是第一个参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录为:%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/Linux/lession1-26&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>,O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录为:%s\n&quot;</span>,buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int rename(const char *oldpath, const char *newpath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = rename(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;rename&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取某个目录下所有的普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为：%d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开目录</span></span><br><span class="line">    DIR * dir = opendir(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="comment">//记录普通文件的个数</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">char</span> * dname = ptr-&gt;d_name;<span class="comment">//获取名称</span></span><br><span class="line">        <span class="comment">//忽略掉 . 和 ..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) ==<span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="comment">//是目录,继续读取</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath,<span class="string">&quot;%s/%s&quot;</span>,path,dname);</span><br><span class="line">            total += getFileNum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">            <span class="comment">//是普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dup-和-dup2-函数"><a href="#dup-和-dup2-函数" class="headerlink" title="dup 和 dup2 函数"></a>dup 和 dup2 函数</h2><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也是指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d , fd1: %d&quot;</span>, fd, fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup2(int oldfd, int newfd);</span></span><br><span class="line"><span class="comment">        作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">        oldfd 指向 a.txt, newfd 指向 b.txt</span></span><br><span class="line"><span class="comment">        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span></span><br><span class="line"><span class="comment">        oldfd 必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">        oldfd和newfd值相同，相当于什么都没有做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>,O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd ==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>,O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 ==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d, fd1: %d\n&quot;</span>, fd,fd1);</span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd,fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d, fd1: %d\n&quot;</span>, fd,fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int fcntl(int fd, int cmd, ... /* args */);</span><br><span class="line">/* fd : 文件描述符</span><br><span class="line">cmd：表示对文件描述符进行如何操作</span><br><span class="line">- F_DUPFD 复制文件描述符，等价于 dup</span><br><span class="line">fcntl(fd, F_DUPFD);</span><br><span class="line">- F_GETFL 获取文件描述符的 flag（就是 open 时指定的 flag）</span><br><span class="line">int flag = fcntl(fd, F_GETFL);</span><br><span class="line">- F_SETFL 设置文件描述符文件状态 flag</span><br><span class="line">- 必选项：O_PDONLY O_WRONLY O_RDWR</span><br><span class="line">- 可选项：O_APPEND追加数据</span><br><span class="line">NONBLOCK 设置成非阻塞*/</span><br><span class="line">int fd = open(&quot;a.txt&quot;, O_RDWR);</span><br><span class="line">int flag = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, G_SETFL, flag | O_APPEND); // 设置成追加写入</span><br></pre></td></tr></table></figure><h2 id="模拟实现-ls-l-命令"><a href="#模拟实现-ls-l-命令" class="headerlink" title="模拟实现 ls -l 命令"></a>模拟实现 ls -l 命令</h2><p>打开当前目录，然后遍历目录，调用 <code>showFile</code> 函数显示该目录下所有文件的信息，文件夹同样是文件，一切皆文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">void showFiles(const char *pathname)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir = opendir(pathname);</span><br><span class="line">    struct dirent *d;</span><br><span class="line">    while ((d = readdir(dir)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (strcmp(d-&gt;d_name, &quot;.&quot;) == 0 || strcmp(d-&gt;d_name, &quot;..&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        showFile(d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取文件信息，最复杂的就是权限信息的显示了，</p><p><a href="https://www.ceyewan.top/images/image-20220619140904963.png"><img src="https://www.ceyewan.top/images/image-20220619140904963.png" alt="image-20220619140904963"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">void showFile(const char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat st;</span><br><span class="line">    int rc = stat(filename, &amp;st);</span><br><span class="line">    if (rc == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;stat&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    char perms[11];</span><br><span class="line">    switch (st.st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    case S_IFLNK:</span><br><span class="line">        perms[0] = &#x27;1&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFDIR:</span><br><span class="line">        perms[0] = &#x27;d&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFREG:</span><br><span class="line">        perms[0] = &#x27;_&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFBLK:</span><br><span class="line">        perms[0] = &#x27;b&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFCHR:</span><br><span class="line">        perms[0] = &#x27;c&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFSOCK:</span><br><span class="line">        perms[0] = &#x27;s&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    case S_IFIFO:</span><br><span class="line">        perms[0] = &#x27;p&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        perms[0] = &#x27;?&#x27;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 文件所有者</span><br><span class="line">    perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">    // 文件所在组</span><br><span class="line">    perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">    // 其他人</span><br><span class="line">    perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;;</span><br><span class="line">    perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">    // 硬连接数</span><br><span class="line">    int linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    // 文件所有者</span><br><span class="line">    char *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    // 文件所在组</span><br><span class="line">    char *fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    // 文件大小</span><br><span class="line">    long int fileSize = st.st_size;</span><br><span class="line"></span><br><span class="line">    // 获取修改的时间，将秒数转化为时间</span><br><span class="line">    char *time = ctime(&amp;st.st_mtime);</span><br><span class="line">    time[strlen(time) - 1] = &#x27;\0&#x27;; // 去掉最后的换行符</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s %d %s %s %ld %s %s\n&quot;, perms, linkNum, fileUser, fileGrp, fileSize,</span><br><span class="line">           time, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果如下，大体上是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">➜  nowcoker ./ls         </span><br><span class="line">_rw-r--r-- 1 ceyewan ceyewan 3738 Sun Jun 19 13:49:26 2022 b.c</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan 4096 Sat Jun 18 16:46:47 2022 gdb</span><br><span class="line">drwxr-xr-x 5 ceyewan ceyewan 4096 Sat Jun 18 15:57:27 2022 calculate</span><br><span class="line">_rw-r--r-- 1 ceyewan ceyewan 2478 Sun Jun 19 14:13:59 2022 a.c</span><br><span class="line">_rwxr-xr-x 1 ceyewan ceyewan 16640 Sun Jun 19 14:14:01 2022 ls</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan 4096 Sat Jun 18 22:14:31 2022 .vscode</span><br><span class="line">_rwxr-xr-x 1 ceyewan ceyewan 16544 Sun Jun 19 14:00:31 2022 a.out</span><br><span class="line">➜  nowcoker ls -l</span><br><span class="line">总用量 56</span><br><span class="line">-rw-r--r-- 1 ceyewan ceyewan  2478  6月 19 14:13 a.c</span><br><span class="line">-rwxr-xr-x 1 ceyewan ceyewan 16544  6月 19 14:00 a.out</span><br><span class="line">-rw-r--r-- 1 ceyewan ceyewan  3738  6月 19 13:49 b.c</span><br><span class="line">drwxr-xr-x 5 ceyewan ceyewan  4096  6月 18 15:57 calculate</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan  4096  6月 18 16:46 gdb</span><br><span class="line">-rwxr-xr-x 1 ceyewan ceyewan 16640  6月 19 14:14 ls</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-系统编程入门&quot;&gt;&lt;a href=&quot;#Linux-系统编程入门&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统编程入门&quot;&gt;&lt;/a&gt;Linux 系统编程入门&lt;/h1&gt;&lt;h2 id=&quot;Linux开发环境搭建&quot;&gt;&lt;a href=&quot;#Li</summary>
      
    
    
    
    <category term="Linux高并发服务器项目" scheme="http://example.com/categories/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode -- Hot100</title>
    <link href="http://example.com/2022/12/04/My-New-Post/"/>
    <id>http://example.com/2022/12/04/My-New-Post/</id>
    <published>2022-12-04T12:36:39.000Z</published>
    <updated>2022-12-09T16:22:57.689Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h5><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li>*<em>只会存在一个有效答案</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(N),空间复杂的：O(1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = hashmap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">while</span>(iter != hashmap.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(N),空间复杂度：0(N),创造哈希表消耗内存</span></span><br></pre></td></tr></table></figure><h5 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h5><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode * sumList = <span class="keyword">new</span> ListNode; <span class="comment">//定义和链表</span></span><br><span class="line">        ListNode * mov = sumList; <span class="comment">//定义移位指针</span></span><br><span class="line">        <span class="type">int</span> sum ; <span class="comment">//定义指针的和</span></span><br><span class="line">        <span class="type">bool</span> carry = <span class="literal">false</span>; <span class="comment">//定义是否进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            mov-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);           </span><br><span class="line">            mov = mov-&gt;next;</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            mov-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h5 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h5><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;<span class="comment">//定义哈希表，存放重复的元素</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;<span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[right]))&#123;</span><br><span class="line">                occ.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">                right++;<span class="comment">//哈希表中没有找到重复的元素，右指针向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,right - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h5><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/归并</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(m + n ,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            nums[k++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m)&#123;</span><br><span class="line">            nums[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)&#123;</span><br><span class="line">            nums[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k % <span class="number">2</span>  ? nums[k/<span class="number">2</span>] : (nums[k/<span class="number">2</span>]+nums[k/<span class="number">2</span> - <span class="number">1</span>])/<span class="number">2.0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O（m+n），空间复杂度：O（m+n）</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法（没看懂）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//中位数 = （left + right）/2</span></span><br><span class="line">        <span class="type">int</span> left = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> right = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + <span class="built_in">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在两个有序数组中找到第k个元素（例如找第一个元素，k=1，即nums[0]）</span></span><br><span class="line">    <span class="comment">//i: nums1的起始位置 j: nums2的起始位置（i，j都是从0开始）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//若nums1为空（或是说其中数字全被淘汰了）</span></span><br><span class="line">        <span class="comment">//在nums2中找第k个元素，此时nums2起始位置是j，所以是j+k-1</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= nums1.<span class="built_in">size</span>())    <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//nums2同理</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= nums2.<span class="built_in">size</span>())    <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)  <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这两个数组的第K/2小的数字，若不足k/2个数字则赋值整型最大值，以便淘汰另一数组的前k/2个数字</span></span><br><span class="line">        <span class="type">int</span> midVal1 = (i + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.<span class="built_in">size</span>()) ? nums1[i + k/<span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        <span class="type">int</span> midVal2 = (j + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.<span class="built_in">size</span>()) ? nums2[j + k/<span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        <span class="comment">//二分法核心部分</span></span><br><span class="line">        <span class="keyword">if</span>(midVal1 &lt; midVal2)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1, i + k/<span class="number">2</span>, nums2, j, k - k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1, i, nums2, j + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Terry</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/median-of-two-sorted-arrays/solutions/485550/zong-he-bai-jia-ti-jie-zong-jie-zui-qing-xi-yi-don/</span></span><br></pre></td></tr></table></figure><h5 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;<span class="comment">//存放结果</span></span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;<span class="comment">//存放子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.<span class="built_in">length</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=temp+s[j];</span><br><span class="line">                string tem=temp;<span class="comment">//tem存放子串反转结果</span></span><br><span class="line">                std::<span class="built_in">reverse</span>(tem.<span class="built_in">begin</span>(),tem.<span class="built_in">end</span>());<span class="comment">//反转</span></span><br><span class="line">                <span class="keyword">if</span>(temp==tem)</span><br><span class="line">                    res=res.<span class="built_in">length</span>()&gt;temp.<span class="built_in">length</span>()?res:temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度:O(n^3),空间复杂负:O(1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当字符串为空或长度为1时，它本身就是最长回文子串</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;<span class="comment">//定义初始回文子串长度为1</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;<span class="comment">//从下标为零处开始</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));<span class="comment">//定义dp[i~j]表示s[i~j]是否为回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;<span class="comment">//初始化,所有长度为1的子串为回文串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归开始</span></span><br><span class="line">        <span class="comment">//枚举子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">            <span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="comment">//由子串长度和左边界何以确定右边界</span></span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果有边界越界，退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//dp[i][j]成立,子串s[i~j]是回文串，比较回文串的长度，取最大</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                        begin = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//substr函数返回从begin开始的maxLen长的字符串</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度:O(n^2),空间复杂负:O(n^2)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中心扩展法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">findCenter</span>(s,i,i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">findCenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(right1 - left1 &gt; end - start)&#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right2 - left2 &gt; end - start)&#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">findCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span>(L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.<span class="built_in">size</span>() &amp;&amp; s[L] == s[R])&#123;</span><br><span class="line">            --L;</span><br><span class="line">            ++R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;L+<span class="number">1</span>, R<span class="number">-1</span>&#125;;<span class="comment">//当跳出循环的时候，L和R已经操作过了，因此需要先退回原状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度:O(n^2),空间复杂负:O(1)</span></span><br></pre></td></tr></table></figure><h5 id="6-正则表达式匹配"><a href="#6-正则表达式匹配" class="headerlink" title="6.正则表达式匹配"></a>6.正则表达式匹配</h5><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划 --没看懂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//匹配*</span></span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                     dp[i][j]=dp[i][j<span class="number">-2</span>]||(dp[i<span class="number">-1</span>][j]&amp;&amp;(s[i<span class="number">-1</span>]==p[j<span class="number">-2</span>]||p[j<span class="number">-2</span>]==<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                     dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&amp;&amp;(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h5&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/12/04/hello-world/"/>
    <id>http://example.com/2022/12/04/hello-world/</id>
    <published>2022-12-04T11:57:10.051Z</published>
    <updated>2022-12-04T11:57:10.051Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
